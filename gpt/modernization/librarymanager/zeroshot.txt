Modernize this code to Java Version 17. There are a total of 7 files to be sent: await all of them before giving me your answer.

File 1:

<ItemLibrary.java>
package com.gizmo385.lm;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

import com.gizmo385.lm.types.Item;

/**
 * Manage a collection of Items and interface with them
 * @author Christopher
 *
 */
public class ItemLibrary {

	private ArrayList<Item> library = new ArrayList<Item>();
	private String saveLocation;
	private String libFileName;

	/**
	 * Initializes the ItemLibrary
	 */
	public ItemLibrary() {
		//create path to save location
		String userHome = System.getProperty( "user.home" );
		String sep = File.separator;
		this.saveLocation = userHome + sep + "gizmo385" + sep + "Library Manager";
		this.libFileName = "library.dat";
		
		verifySaveFileLoc();
		
		//Load and print success
		System.out.println( "Load status: " + load() );
	}

	/**
	 * Searches the tags of each item and returns matchings Items
	 * @param tagToMatch The tag to match
	 * @return An ArrayList containing items that match the tag
	 */
	public final ArrayList<Item> searchByTag( String tagToMatch ) {
		ArrayList<Item> results = new ArrayList<Item>();

		for( Item i : this.library )
			if( i.tagPresent( tagToMatch ) )
				results.add( i );

		return results;
	}

	/**
	 * Clears out the library
	 */
	public final boolean truncateLibrary() {
		this.library = new ArrayList<Item>();
		return save();
	}
	
	/**
	 * Verifies the location of the save file.
	 * 
	 * <p>Will create parent directories and the file itself if they're not present in the file system</p>
	 */
	private final void verifySaveFileLoc() {
		try {
			File saveFile = new File( saveLocation, libFileName );
			if( ! saveFile.getParentFile().exists() )
				saveFile.getParentFile().mkdirs();
			
			if( ! saveFile.exists() )
				saveFile.createNewFile();
		} 
		catch ( IOException ioe ) {
			System.err.println( ioe );
		}
	}
	
	/**
	 * Saves the library to the designated save location
	 * @return The success or failure of the save operation.
	 */
	public final boolean save() {
		verifySaveFileLoc();
		
		try {
			File file = new File( this.saveLocation, this.libFileName );
			file.createNewFile();
			FileOutputStream fos = new FileOutputStream( file );
			ObjectOutputStream oos = new ObjectOutputStream( fos );
			
			//Write each Item to the file
			for( Item i : this.library ) {
				oos.writeObject( i );
			}
			
			//Close stream
			oos.close();
			return true;
		}
		catch( IOException ioe ) {
			return false;
		}
	}
	
	/**
	 * Loads the library from the file, located in the designated save location
	 * @return The ArrayList of items
	 */
	public final boolean load() {
		verifySaveFileLoc();
		
		try {
			FileInputStream fis = new FileInputStream( new File( this.saveLocation, this.libFileName ) );
			@SuppressWarnings("resource")
			ObjectInputStream ois = new ObjectInputStream( fis );
			
			this.library = new ArrayList<Item>();
			
			//Read until EOFException (end of file) is thrown 
			while( true ) {
				this.library.add( (Item) ois.readObject() );
			}
		}
		catch( EOFException eof ) {
			return true;
		}
		catch( IOException ioe ) {
			//An I/O exception of some kind as occured.
			System.err.println( ioe );
			return false;
		}
		catch( ClassNotFoundException cnfe ) {
			return false;
		}
	}

	/**
	 * Removes the specified item from the library
	 * @param item The item to remove
	 */
	public void deleteItem( Item item ) {
		this.library.remove( item );
	}

	/**
	 * Remove an item from the specified index
	 * @param index The index of the item to remove
	 */
	public void deleteItem( int index ) {
		this.library.remove( index );
	}

	/**
	 * Returns an item at a specified index
	 * @param index The index of the item to return
	 * @return The item at the specified index
	 */
	public Item getItem( int index ) {
		return this.library.get( index );
	}
	
	/**
	 * Adds an item to the library
	 * @param i The item to add
	 */
	public void add( Item i ) {
		this.library.add( i );
	}

	/**
	 * Returns a copy of the array list
	 * @return A copy of the instance ArrayList
	 */
	public ArrayList<Item> getLibrary () {
		return new ArrayList<Item>( this.library );
	}
}
</ItemLibrary.java>

File 2:
<types/Album.java>
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a music album
 * @author Christopher
 *
 */
public class Album extends Item {
	private static final long serialVersionUID = -6654556798874693337L;
	
	private String artist, label;
	private ArrayList<String> songs;
	private int yearReleased;

	public Album( String name, String genre, String id, int copies, ArrayList<String> tags, String artist, String label, ArrayList<String> songs, int yearReleased ) {
		super( "album", name, genre, id, copies, tags );
		this.artist = artist;
		this.label = label;
		this.songs = new ArrayList<String>( songs );
		this.yearReleased = yearReleased;
	}

	/**
	 * @return This album's artist
	 */
	public String getArtist() {
		return artist;
	}

	/**
	 * @return This album's label
	 */
	public String getLabel() {
		return label;
	}

	/**
	 * @return This album's song list
	 */
	public ArrayList<String> getSongs() {
		return new ArrayList<String>( this.songs );
	}

	/**
	 * @return The year this album was released
	 */
	public int getYearReleased() {
		return yearReleased;
	}

	/**
	 * @param artist This album's artist
	 */
	public void setArtist(String artist) {
		this.artist = artist;
	}

	/**
	 * @param label This album's label
	 */
	public void setLabel(String label) {
		this.label = label;
	}

	/**
	 * @param songs This album's song list
	 */
	public void setSongs(ArrayList<String> songs) {
		this.songs = new ArrayList<String>( songs );
	}

	/**
	 * @param yearReleased The year this album was released
	 */
	public void setYearReleased(int yearReleased) {
		this.yearReleased = yearReleased;
	}

	/**
	 * {@inheritDoc}
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String lineSep = System.lineSeparator();

		sb.append( "Title: ").append( this.getName() ).append( lineSep );
		sb.append( "Artist: " ).append( this.getArtist() ).append( lineSep );
		sb.append( "Music label: " ).append( this.getLabel() ).append( lineSep );
		sb.append( "Music genre: " ).append( this.getGenre() ).append( lineSep );
		sb.append( "Song list: " );
		for( int i = 0; i < this.songs.size(); i++ )
			sb.append( this.songs.get(i) ).append( ", " );
		sb.append( lineSep );
		sb.append( "Released in: " ).append( this.getYearReleased() ).append( lineSep );

		return sb.toString();
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean saveToFile(BufferedWriter fileOut) {
		String lineSep = System.lineSeparator();

		try {
			fileOut.write( "[album]" );
			fileOut.write( lineSep );
			fileOut.write( this.getName() );
			fileOut.write( lineSep );
			fileOut.write( this.getGenre() );
			fileOut.write( lineSep );
			fileOut.write( this.getId() );
			fileOut.write( lineSep );
			fileOut.write( this.getCopies() );
			fileOut.write( lineSep );
			for( String s : this.getTags() ) //save tags and delimit each tag with a semicolon
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
			fileOut.write( this.getArtist() );
			fileOut.write( lineSep );
			fileOut.write( this.getLabel() );
			fileOut.write( lineSep );
			fileOut.write( this.getYearReleased() );
			fileOut.write( lineSep );
			for( String s : this.getSongs() )
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
		}
		catch( IOException ioe ) {
			return false;
		}
		return true;
	}

	/**
	 * Loads this item from the file associated with fileScan
	 * @param fileScan The Scanner that is reading from the load file
	 * @return The Item loaded from the Scanner
	 */
	public static Item loadFromFile( Scanner fileScan ) {
		//Load lines from the file
		String name = fileScan.nextLine();
		String genre = fileScan.nextLine();
		String id = fileScan.nextLine();
		int copies = Integer.parseInt( fileScan.nextLine() );
		String tagLine = fileScan.nextLine();
		String artist = fileScan.nextLine();
		String label = fileScan.nextLine();
		int yearReleased = Integer.parseInt( fileScan.nextLine() );
		String songLine = fileScan.nextLine();

		//Parse tags
		ArrayList<String> tags = new ArrayList<String>();
		Scanner tagParser = new Scanner( tagLine );
		tagParser.useDelimiter( ";" );
		while( tagParser.hasNext() )
			tags.add( tagParser.next() );
		tagParser.close();

		//Parse song list
		ArrayList<String> songs = new ArrayList<String>();
		Scanner songLineParser = new Scanner( songLine );
		songLineParser.useDelimiter(";" );
		while( songLineParser.hasNext() )
			songs.add( songLineParser.next() );
		songLineParser.close();

		return new Album( name, genre, id, copies, tags, artist, label, songs, yearReleased );
	}
}
<types/Album.java>

File 3:
<types/Book.java>
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a book
 * @author Christopher
 *
 */
public class Book extends Item {
	private static final long serialVersionUID = -120108029461760655L;
	
	private int yearPublished;
	private String author, publisher;
	
	/**
	 * Instantiates this book object passing the tag "#book" to the superconstructor
	 * @param name The name of this book
	 * @param genre The genre of this book
	 * @param id This book's ID
	 * @param copies The number of copies of this book in inventory
	 * @param tags Words associated with this book for searching
	 * @param author The author of this book
	 * @param publisher The book's publisher
	 * @param yearPublished The year this book was published
	 */
	public Book( String name, String genre, String id, int copies, ArrayList<String> tags, String author, String publisher, int yearPublished ) {
		super( "book", name, genre, id, copies, tags );
		this.author = author;
		this.publisher = publisher;
		this.yearPublished = yearPublished;
		
		//Add necessary tags
		this.addTags( this.author, this.publisher );
	}
	
	/**
	 * @return The year this book was published
	 */
	public int getYearPublished() {
		return yearPublished;
	}

	/**
	 * @return The author of this book
	 */
	public String getAuthor() {
		return author;
	}


	/**
	 * @return The publisher of this book
	 */
	public String getPublisher() {
		return publisher;
	}

	/**
	 * @param yearPublished The year this book was published
	 */
	public void setYearPublished(int yearPublished) {
		this.yearPublished = yearPublished;
	}

	/**
	 * @param author The author of this book
	 */
	public void setAuthor(String author) {
		this.author = author;
	}

	/**
	 * @param publisher The publisher of this book
	 */
	public void setPublisher(String publisher) {
		this.publisher = publisher;
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean saveToFile( BufferedWriter fileOut ) {
		String lineSep = System.lineSeparator();
		
		try {
			fileOut.write( "[book]" );
			fileOut.write( lineSep );
			fileOut.write( this.getName() );
			fileOut.write( lineSep );
			fileOut.write( this.getGenre() );
			fileOut.write( lineSep );
			fileOut.write( this.getId() );
			fileOut.write( lineSep );
			fileOut.write( this.getCopies() );
			fileOut.write( lineSep );
			for( String s : this.getTags() ) //save tags and delimit each tag with a semicolon
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
			fileOut.write( this.getAuthor() );
			fileOut.write( lineSep );
			fileOut.write( this.getPublisher() );
			fileOut.write( lineSep );
			fileOut.write( this.getYearPublished() );
			fileOut.write( lineSep );
		}
		catch( IOException ioe ) {
			return false;
		}
		return true;
	}

	/**
	 * Loads this item from the file associated with fileScan
	 * @param fileScan The Scanner that is reading from the load file
	 * @return The Item loaded from the Scanner
	 */
	public static Item loadFromFile( Scanner fileScan ) {
		try {
			//Load lines from the file
			String name = fileScan.nextLine();
			String genre = fileScan.nextLine();
			String id = fileScan.nextLine();
			int copies = Integer.parseInt( fileScan.nextLine() );
			String tagLine = fileScan.nextLine();
			String author = fileScan.nextLine();
			String publisher = fileScan.nextLine();
			int yearPublished = Integer.parseInt( fileScan.nextLine() );
			
			//Parse tags
			ArrayList<String> tags = new ArrayList<String>();
			Scanner tagParser = new Scanner( tagLine );
			tagParser.useDelimiter( ";" );
			while( tagParser.hasNext() )
				tags.add( tagParser.next() );
			tagParser.close();
			
			return new Book( name, genre, id, copies,tags, author, publisher, yearPublished );
		} catch (NumberFormatException e) {
			System.err.println( "Error loading book." + e.toString() );
			return null;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public String toString() {
        StringBuilder sb = new StringBuilder();
        String lineSep = System.lineSeparator(); //line separator
        
        sb.append( "Name: ").append( this.getName() ).append( lineSep );
        sb.append( "Author: " ).append( this.getAuthor() ).append( lineSep );
        sb.append( "Genre: " ).append( this.getGenre() ).append( lineSep );
        sb.append( "Published in " ).append( this.getYearPublished() ).append( " by " ).append( this.getPublisher() ).append( lineSep );
        sb.append( "Copies owned: " ).append( this.getCopies() ).append( lineSep );
        sb.append( "ISBN: " ).append( this.getId() ).append( lineSep );
        return sb.toString();
	}
}
</types/Book.java>

File 3:
<types/Item.java>
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.Serializable;
import java.util.ArrayList;

/**
 * Abstract class representing an Item. Superclass to all other items
 * @author Christopher
 *
 */
public abstract class Item implements Comparable<Item>, Serializable {
	private static final long serialVersionUID = -2518470675811167937L;
	
	private final String ITEM_TYPE;
	private String name, genre, id;
	private int copies;
	private ArrayList<String> tags;

	/**
	 * Constructor for the abstract Item class
	 * @param itemType The type of item extending this abstract class (book, movie, etc)
	 * @param name The name of this item
	 * @param genre This genre this item falls under
	 * @param id This item's ID (isbn, barcode, etc)
	 * @param copies The number of copies of this item in inventory
	 * @param tags Word associated with this item used for searching
	 */
	public Item( String itemType, String name, String genre, String id, int copies, ArrayList<String> tags ) {
		this.ITEM_TYPE = itemType.toLowerCase();
		this.name = name;
		this.genre = genre;
		this.id = id;
		this.copies = copies > 0 ? copies : 0;

		//Instatiate the ArrayList
		this.tags = new ArrayList<String>();

		//Add passed ArrayList contents to the tags
		for( String s : tags )
			if( ! this.tags.contains( s.toLowerCase() ) )
				this.tags.add( s.toLowerCase() );

		//Add additional tag information if not already present
		if( ! this.tags.contains( this.name.toLowerCase() ) )
			this.tags.add( this.name.toLowerCase() );
		if( ! this.tags.contains( this.genre.toLowerCase() ) )
			this.tags.add( this.genre.toLowerCase() );
		if( ! this.tags.contains( this.id.toLowerCase() ) )
			this.tags.add( this.id.toLowerCase() );
		if( ! this.tags.contains( this.ITEM_TYPE.toLowerCase() ) )
			this.tags.add( this.ITEM_TYPE.toLowerCase() );
	}
	
	/**
	 * @return The name of the item
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * @return The ITEM_TYPE associated with this item (Book, movie, etc)
	 */
	public String getItemType() {
		return this.ITEM_TYPE;
	}

	/**
	 * @return The genre of the item
	 */
	public String getGenre() {
		return genre;
	}

	/**
	 * @return The ID string (barcode, isbn, id number, etc) of the item
	 */
	public String getId() {
		return id;
	}

	/**
	 * @return The number of copies of this item in inventory
	 */
	public int getCopies() {
		return copies;
	}

	/**
	 * @return The "tags" - words associated with this item used for searching
	 */
	public ArrayList<String> getTags() {
		return new ArrayList<String>( this.tags );
	}

	/**
	 * @param name The name of this item
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * @param genre The genre of this item
	 */
	public void setGenre(String genre) {
		this.genre = genre;
	}

	/**
	 * @param id The id of this item
	 */
	public void setId(String id) {
		this.id = id;
	}

	/**
	 * @param copies The number of copies of this item in inventroy
	 */
	public void setCopies(int copies) {
		this.copies = copies;
	}

	/**
	 * @param tags The "tags" - words associated with this item used for searching
	 */
	public void setTags(ArrayList<String> tags) {
		//Re instatiate the ArrayList
		this.tags = new ArrayList<String>();

		//Add passed ArrayList contents to the tags
		for( String s : tags )
			if( ! this.tags.contains( s.toLowerCase() ) )
				this.tags.add( s.toLowerCase() );

		//Add additional tag information if not already present
		if( ! this.tags.contains( this.name.toLowerCase() ) )
			this.tags.add( this.name.toLowerCase() );
		if( ! this.tags.contains( this.genre.toLowerCase() ) )
			this.tags.add( this.genre.toLowerCase() );
		if( ! this.tags.contains( this.id.toLowerCase() ) )
			this.tags.add( this.id.toLowerCase() );
	}
	
	/**
	 * Adds a tag to this Item's tag list
	 * @param tag The tag to add
	 * @return If the tag was added or not
	 * 
	 * <p>Use {@link #tagPresent( String tag )} to add multiple tags in one method call </p>
	 */
	public boolean addTag( String tag ) {
		return this.tagPresent( tag ) ? this.tags.add( tag.toLowerCase() ) : false;
	}
	
	/**
	 * Adds an unspecified amount of tags to the Item's tag list
	 * @param tags A collection of Strings of unspecified size
	 * 
	 * <p>Use {@link #addTag( String tag )} to add individual tags </p>
	 */
	public void addTags( String... tags ) {
		for( int i = 0; i < tags.length; i++ )
			this.addTag( tags[i] );
		
	}
	
	/**
	 * Removes a tag from this Item's tag list
	 * @param tag The tag to be removed
	 * @return If the tag was removed or not
	 */
	public boolean removeTag( String tag ) {
		return this.tagPresent( tag ) ? this.tags.remove( tag.toLowerCase() ) : false;
	}
	
	/**
	 * Checks if a tag is present in this Item's tags
	 * @param tag The tag to check for
	 * @return Whether or not the tag was present
	 */
	public boolean tagPresent( String tag ) {
		return this.tags.contains( tag.toLowerCase() );
	}
	
	/**
	 * Compares the names of these two items
	 */
	public int compareTo( Item i ) {
		return this.name.compareTo( i.getName() );
	}
	
	/**
	 * The equals method for this Item
	 */
	public boolean equals( Object o ) {
		if( o instanceof Item ) {
			Item i = (Item)o;
			return this.name.equals( i.getName() ) && this.genre.equals( i.getGenre() ) && this.id.equals( i.getId() );
		}
		return false;
	}
	
	/**
	 * The string representation of this Item
	 */
	public abstract String toString();
	
	/**
	 * Saves this item to the file associated with fileOut
	 * @param fileOut The BufferedWriter that is writing to the save file
	 * @return The success/failure of the save operation for this Item
	 */
	public abstract boolean saveToFile( BufferedWriter fileOut );
}
</types/Item.java>
ChatGPT said:
Reasoned about Java 17 code modernization for 5 seconds
Okay, so we need to modernize code to Java 17, and there are a total of 7 files. So far, I have 4: ItemLibrary.java (File 1), Album.java (File 2), Book.java (File 3), and Item.java (File 4). But wait, there seems to be some confusion with the numbering. The prompt says there are 7 files in total, so I must gather all of them before proceeding with an answer. I need to double-check the information to avoid making any assumptions.

I'll wait for the remaining files before providing my updated Java 17 version.







You said:
File 4:
<types/Movie.java>
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a Movie
 * @author Christopher
 *
 */
public class Movie extends Item {
	private static final long serialVersionUID = -4801301178032374860L;
	
	private String director, rating;
	private int yearReleased;
	private ArrayList<String> stars;

	public Movie( String name, String genre, String id, int copies, ArrayList<String> tags, String director, String rating, int yearReleased, ArrayList<String> stars ) {
		super( "movie", name, genre, id, copies, tags );
		this.director = director;
		this.rating = rating;
		this.yearReleased = yearReleased;
		this.stars = new ArrayList<String>( stars );
	}

	/**
	 * @return The director of this movie
	 */
	public String getDirector() {
		return director;
	}

	/**
	 * @return The rating of this movie (E, R, NC-17, etc)
	 */
	public String getRating() {
		return rating;
	}

	/**
	 * @return The year this movie was released
	 */
	public int getYearReleased() {
		return yearReleased;
	}

	/**
	 * @return The stars of this movie
	 */
	public ArrayList<String> getStars() {
		return new ArrayList<String>( this.stars );
	}

	/**
	 * @param director The director of this movie
	 */
	public void setDirector(String director) {
		this.director = director;
	}

	/**
	 * @param rating The rating of this movie (E, R, NC-17, etc)
	 */
	public void setRating(String rating) {
		this.rating = rating;
	}

	/**
	 * @param yearReleased The year this movie was released
	 */
	public void setYearReleased(int yearReleased) {
		this.yearReleased = yearReleased;
	}

	/**
	 * @param stars The stars of this movie
	 */
	public void setStars(ArrayList<String> stars) {
		this.stars = new ArrayList<String>( stars );
	}


	/**
	 * {@inheritDoc}
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String lineSep = System.lineSeparator();

		sb.append( "Title: ").append( this.getName() ).append( lineSep );
		sb.append( "Director: " ).append( this.getDirector() ).append( lineSep );
		sb.append( "Starring: " );
		for( String s : this.stars ) 
			sb.append( s + ", " );
		sb.append( lineSep ).append( "Genre: " ).append( this.getGenre() ).append( lineSep );
		sb.append( "Rated: " ).append( this.getRating() );
		sb.append( "Released in " ).append( this.getYearReleased () ).append( lineSep );
		
		
		return sb.toString();
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean saveToFile(BufferedWriter fileOut) {
		String lineSep = System.lineSeparator();

		try {
			fileOut.write( "[movie]" );
			fileOut.write( lineSep );
			fileOut.write( this.getName() );
			fileOut.write( lineSep );
			fileOut.write( this.getGenre() );
			fileOut.write( lineSep );
			fileOut.write( this.getId() );
			fileOut.write( lineSep );
			fileOut.write( this.getCopies() );
			fileOut.write( lineSep );
			for( String s : this.getTags() ) //save tags and delimit each tag with a semicolon
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
			fileOut.write( this.getDirector() );
			fileOut.write( lineSep );
			fileOut.write( this.getRating() );
			fileOut.write( lineSep );
			fileOut.write( this.getYearReleased() );
			fileOut.write( lineSep );
			for( String s : this.stars )
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
		}
		catch( IOException ioe ) {
			return false;
		}
		return true;
	}

	/**
	 * Loads this item from the file associated with fileScan
	 * @param fileScan The Scanner that is reading from the load file
	 * @return The Item loaded from the Scanner
	 */
	public static Item loadFromFile( Scanner fileScan ) {
		//Load lines from the file
		String name = fileScan.nextLine();
		String genre = fileScan.nextLine();
		String id = fileScan.nextLine();
		int copies = Integer.parseInt( fileScan.nextLine() );
		String tagLine = fileScan.nextLine();
		String director = fileScan.nextLine();
		String rating = fileScan.nextLine();
		int yearReleased = Integer.parseInt( fileScan.nextLine() );
		String starsLine = fileScan.nextLine();

		//Parse tags
		ArrayList<String> tags = new ArrayList<String>();
		Scanner tagParser = new Scanner( tagLine );
		tagParser.useDelimiter( ";" );
		while( tagParser.hasNext() )
			tags.add( tagParser.next() );
		tagParser.close();

		//Parse songs
		ArrayList<String> stars = new ArrayList<String>();
		Scanner starsLineParser = new Scanner( starsLine );
		starsLineParser.useDelimiter( ";" );
		while( starsLineParser.hasNext() )
			stars.add( starsLineParser.next() );
		starsLineParser.close();
		
		return new Movie( name, genre, id, copies, tags, director, rating, yearReleased, stars );
	}
}
</types/Movie.java>

File 5:
<types/VideoGame.java>
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a video game
 * @author Christopher
 *
 */
public class VideoGame extends Item {
	private static final long serialVersionUID = -6305473299083489814L;
	
	private String developer, publisher, console, contentRating;
	
	public VideoGame( String name, String genre, String id, int copies, ArrayList<String> tags, String developer, String publisher, String console, String contentRating ) {
		super( "video game", name, genre, id, copies, tags );
		this.developer = developer;
		this.publisher = publisher;
		this.console = console;
		this.contentRating = contentRating;
		
		//Add tags necessary tags
		this.addTags( this.developer, this.publisher, this.console, this.contentRating );
	}
	
	/**
	 * @return The game developer for this VideoGame
	 */
	public String getDeveloper() {
		return developer;
	}

	/**
	 * @return The publisher for this video game
	 */
	public String getPublisher() {
		return publisher;
	}

	/**
	 * @return The console this video game is owned for (PC, Xbox360, SNES, etc)
	 */
	public String getConsole() {
		return console;
	}

	/**
	 * @return This video game's content rating (i.e: PEGI 16, M, E10+, etc)
	 */
	public String getContentRating() {
		return contentRating;
	}

	/**
	 * @param developer The game developer for this VideoGame
	 */
	public void setDeveloper(String developer) {
		this.developer = developer;
	}

	/**
	 * @param publisher The publisher for this video game
	 */
	public void setPublisher(String publisher) {
		this.publisher = publisher;
	}
	
	/**
	 * @param console The console this game is owned for (PC, Xbox360, SNES, etc)
	 */
	public void setConsole(String console) {
		this.console = console;
	}


	/**
	 * @param contentRating This video game's content rating (i.e: PEGI 16, M, E10+, etc)
	 */
	public void setContentRating(String contentRating) {
		this.contentRating = contentRating;
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean saveToFile(BufferedWriter fileOut) {
		String lineSep = System.lineSeparator();
		
		try {
			fileOut.write( "[videogame]" );
			fileOut.write( lineSep );
			fileOut.write( this.getName() );
			fileOut.write( lineSep );
			fileOut.write( this.getGenre() );
			fileOut.write( lineSep );
			fileOut.write( this.getId() );
			fileOut.write( lineSep );
			fileOut.write( this.getCopies() );
			fileOut.write( lineSep );
			for( String s : this.getTags() ) //save tags and delimit each tag with a semicolon
				fileOut.write( s + ";" );
			fileOut.write( lineSep );
			fileOut.write( this.getDeveloper() );
			fileOut.write( lineSep );
			fileOut.write( this.getPublisher() );
			fileOut.write( lineSep );
			fileOut.write( this.getConsole() );
			fileOut.write( lineSep );
			fileOut.write( this.getContentRating() );
			fileOut.write( lineSep );
		}
		catch( IOException ioe ) {
			return false;
		}
		return true;
	}

	/**
	 * Loads this item from the file associated with fileScan
	 * @param fileScan The Scanner that is reading from the load file
	 * @return The Item loaded from the Scanner
	 */
	public static Item loadFromFile(Scanner fileScan) {
		//Load lines from the file
		String name = fileScan.nextLine();
		String genre = fileScan.nextLine();
		String id = fileScan.nextLine();
		int copies = Integer.parseInt( fileScan.nextLine() );
		String tagLine = fileScan.nextLine();
		String developer = fileScan.nextLine();
		String publisher = fileScan.nextLine();
		String console = fileScan.nextLine();
		String contentRating = fileScan.nextLine();
		
		//Parse tags
		ArrayList<String> tags = new ArrayList<String>();
		Scanner tagParser = new Scanner( tagLine );
		tagParser.useDelimiter( ";" );
		while( tagParser.hasNext() )
			tags.add( tagParser.next() );
		tagParser.close();
		
		return new VideoGame( name, genre, id, copies, tags, developer, publisher, console, contentRating );
	}

	/**
	 * {@inheritDoc}
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String lineSep = System.lineSeparator(); //line separator
		
		sb.append( "Title: " ).append( this.getName() ).append( lineSep );
		sb.append( "Genre: " ).append( this.getGenre() ).append( lineSep );
		sb.append( "Developer: " ).append( this.getDeveloper() ).append( lineSep );
		sb.append( "Publisher: " ).append( this.getPublisher() ).append( lineSep );
		sb.append( "Console: " ).append( this.getConsole() ).append( lineSep );
		sb.append( "Rating: " ).append( this.getContentRating() ).append( lineSep );
		sb.append( "Copies owned: " ).append( this.getCopies() ).append( lineSep );
		
		return sb.toString();
	}
}
</types/VideoGame.java>

File 6:
<gui/LibraryManagerFrame.java>
package com.gizmo385.lm.gui;

import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.ArrayList;
import java.util.HashMap;

import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import com.gizmo385.lm.ItemLibrary;
import com.gizmo385.lm.gui.dialogs.AddItemDialog;
import com.gizmo385.lm.types.Item;

/**
 * Primary window for the Library Manager
 * 
 * <p>This window allows the user to interact with their library. Selecting items from the JList will display their full contents
 * within the JTextArea. This allows for many items to be displayed at the same time without crowding the screen. Search
 * capabilities are also provided so that the user can search for items based on items they're tagged with.</p>
 * 
 * @author Christopher
 *
 */
public class LibraryManagerFrame extends JFrame implements ActionListener, ListSelectionListener, ItemListener, WindowListener {

	//Objects
	private ItemLibrary library;
	private HashMap<String, Item> titlesToItems;
	private DefaultListModel<String> defaultListModel, currentListModel;
	
	//Dialogs
	private AddItemDialog aid;

	//Components
	private JList<String> itemsDisplaying;
	private JTextArea detailedItemDisplay;
	private JTextField searchQuery;
	private JButton search, cancel, deleteSelectedItems;
	private JScrollPane listScrollPane, textAreaScrollPane;
	private JComboBox<String> itemSelection;

	//Final Variables
	private static final long serialVersionUID = -8264093334345119816L;
	private static final int WIDTH = 535;
	private static final int HEIGHT = 430;

	/**
	 * Calls initialization method and manages JFrame settings.
	 */
	public LibraryManagerFrame() {
		super( "Library Manager" );

		init();

		super.setSize( WIDTH, HEIGHT );
		super.setLayout( new FlowLayout() );
		super.setVisible( true );
		super.setResizable( false );
		super.setLocationRelativeTo( null );
		super.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	}
	
	/**
	 * Loads library entires into the DefaultListModel and displays it.
	 */
	private final void reloadLibraryEntries() {
		this.library = new ItemLibrary();
		this.titlesToItems = new HashMap<String, Item>();
		this.defaultListModel = new DefaultListModel<String>();

		for( Item i : this.library.getLibrary() ) {
			this.defaultListModel.addElement( i.getName() );
			this.titlesToItems.put( i.getName(), i );
		}
		
		this.currentListModel = defaultListModel;
	}

	private final void init() {
		//Objects
		reloadLibraryEntries();

		//JList
		this.itemsDisplaying = new JList<String>( this.defaultListModel );
		this.itemsDisplaying.setSelectionMode( ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );
		this.itemsDisplaying.setToolTipText( "Select items here for detailed representations to the right." );
		this.itemsDisplaying.addListSelectionListener( this ); 
		
		//Text area
		this.detailedItemDisplay = new JTextArea( 20, 22 );
		this.detailedItemDisplay.setEditable( false );
		this.detailedItemDisplay.setToolTipText( "Items selected to the left will display here." );

		//Scroll panes
		this.listScrollPane = new JScrollPane( this.itemsDisplaying );
		this.listScrollPane.setBorder( BorderFactory.createTitledBorder( "Items in the library: " ) );
		this.listScrollPane.setPreferredSize( new Dimension( 250, 345 ) );

		this.textAreaScrollPane = new JScrollPane( this.detailedItemDisplay );
		this.textAreaScrollPane.setBorder( BorderFactory.createTitledBorder( "Items currently selected: " ) );

		//Text field
		this.searchQuery = new JTextField( 15 );
		this.searchQuery.addActionListener( this );

		//Buttons
		this.search = new JButton( "Search" );
		this.search.addActionListener( this );
		
		this.deleteSelectedItems = new JButton( "Delete" );
		this.deleteSelectedItems.addActionListener( this );
		
		this.cancel = new JButton( "Cancel" );
		this.cancel.addActionListener( this );
		
		//Combo Box
		this.itemSelection = new JComboBox<String>();
		this.itemSelection.addItem( "---Add Item---" );
		this.itemSelection.addItem( "Book" );
		this.itemSelection.addItem( "Video Game" );
		this.itemSelection.addItem( "Album" );
		this.itemSelection.addItem( "Movie" );
		this.itemSelection.addItemListener( this );
		
		//Add components
		super.add( this.listScrollPane );
		super.add( this.textAreaScrollPane );
		super.add( this.searchQuery );
		super.add( this.search );
		super.add( this.cancel );
		super.add( this.itemSelection );
		super.add( this.deleteSelectedItems );
	}

	/**
	 * Manage button actions
	 */
	public void actionPerformed(ActionEvent ae) {
		if( ae.getSource() == this.searchQuery || ae.getSource() == this.search ) {
			//displays results matching the query typed into the search box
			ArrayList<Item> results = this.library.searchByTag( this.searchQuery.getText() );
			
			this.currentListModel = new DefaultListModel<String>();
			for( Item i : results ) {
				this.currentListModel.addElement( i.getName() );
			}
			
			this.itemsDisplaying.setModel( this.currentListModel );
		}
		
		else if( ae.getSource() == this.cancel ) {
			//clears out all searches, restores default list model
			this.searchQuery.setText("");
			this.detailedItemDisplay.setText("");
			this.itemsDisplaying.setModel( this.defaultListModel );
			this.currentListModel = this.defaultListModel;
		}
		
		else if( ae.getSource() == this.deleteSelectedItems ) {
			int[] selected = this.itemsDisplaying.getSelectedIndices();
			
			if( selected.length == 0 ) {
				JOptionPane.showMessageDialog( this, "No items have been selected.", "No items selected.", JOptionPane.ERROR_MESSAGE );
			}
			else {
				int confirmation = JOptionPane.showConfirmDialog( this, "Are you sure you wish to delete" + selected.length + " item(s) from the library?", "Confirm deletion.", JOptionPane.YES_NO_OPTION );
				
				if( confirmation == JOptionPane.YES_OPTION ) {
					for( int i : selected ) {
						this.library.deleteItem( this.titlesToItems.get( this.currentListModel.get( i ) ) );
					}
					
					this.library.save();
					this.library.load();
					reloadLibraryEntries();
					this.itemsDisplaying.setModel( this.defaultListModel );
				}
			}
		}
	}

	/**
	 * Manage item selections in the JList
	 */
	public void valueChanged(ListSelectionEvent ise) {
		if( ise.getSource() == this.itemsDisplaying ) {
			//displays toString() method of the selected items
			this.detailedItemDisplay.setText("");
			int[] selected = this.itemsDisplaying.getSelectedIndices();
			
			for( int i : selected ) {
				this.detailedItemDisplay.append( this.titlesToItems.get( this.currentListModel.get( i ) ).toString() + System.lineSeparator() );
			}
		}
	}
	
	/**
	 * Manage combo box selection
	 */
	public void itemStateChanged(ItemEvent ie) {
		if( ie.getSource() == this.itemSelection && ie.getStateChange() == ItemEvent.SELECTED ) {
			String s = (String)this.itemSelection.getSelectedItem();
			if( s.equals( "Book" ) ) {
				this.aid = new AddItemDialog( this, true, this.library, "book" );
				this.aid.addWindowListener( this );
			}
			else if( s.equals("Album" ) ) {
				this.aid = new AddItemDialog( this, true, this.library, "album" );
				this.aid.addWindowListener( this );
			}
			else if( s.equals( "Movie" ) ) {
				this.aid = new AddItemDialog( this, true, this.library, "movie" );
				this.aid.addWindowListener( this );
			}
			else if(s.equals( "Video Game" ) ) {
				this.aid = new AddItemDialog( this, true, this.library, "videogame" );
				this.aid.addWindowListener( this );
			}
		}
	}

	/**
	 * Create instance of LibraryManagerFrame
	 */
	public static void main( String[] args ) {
		@SuppressWarnings("unused")
		LibraryManagerFrame lmf = new LibraryManagerFrame();
	}

	/** Unused */
	public void windowActivated(WindowEvent e) { }

	/** Manages window closing */
	public void windowClosed(WindowEvent e) { 
		reloadLibraryEntries();
		this.itemsDisplaying.setModel( this.defaultListModel );
	}

	/** Manages window closing */
	public void windowClosing(WindowEvent e) { 
		reloadLibraryEntries();
		this.itemsDisplaying.setModel( this.defaultListModel );
	}

	/** Unused */
	public void windowDeactivated(WindowEvent e) { }

	/** Unused */
	public void windowDeiconified(WindowEvent e) { }

	/** Unused */
	public void windowIconified(WindowEvent e) { }

	/** Unused */
	public void windowOpened(WindowEvent e) { }
}
</gui/LibraryManagerFrame.java>
ChatGPT said:
Reasoned about Java 17 code modernization for 6 seconds
I'll wait for file 7 before providing my updated Java 17 version.







You said:
File 7:
<gui/dialogs/AddItemDialog.java>
package com.gizmo385.lm.gui.dialogs;

import java.awt.CardLayout;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.regex.Pattern;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

import com.gizmo385.lm.ItemLibrary;
import com.gizmo385.lm.types.Album;
import com.gizmo385.lm.types.Book;
import com.gizmo385.lm.types.Movie;
import com.gizmo385.lm.types.VideoGame;

/**
 * This dialog is used to add items to the library.
 * 
 * @author Christopher
 *
 */
public class AddItemDialog extends JDialog implements ActionListener {
	ItemLibrary lib;

	//Item types
	private final String BOOK = "book";
	private final String MOVIE = "movie";
	private final String ALBUM = "album";
	private final String VIDEOGAME = "videogame";

	//addBook components
	private JTextField bookName, bookGenre, bookAuthor, bookId, bookTags, bookCopies, bookPublisher, bookYearPublished;
	private JButton submitBook, cancelBook;

	//addMovie components
	private JTextField movieName, movieGenre, movieId, movieTags, movieCopies, movieDirector, movieRating, movieStars, movieYearReleased;
	private JButton submitMovie, cancelMovie;

	//addVideoGame components
	private JTextField videoGameName, videoGameGenre, videoGameId, videoGameTags, videoGameConsole, videoGameDeveloper, videoGamePublisher, videoGameContentRating, videoGameCopies;
	private JButton submitVideoGame, cancelVideoGame;

	//addAlbum components
	private JTextField albumName, albumGenre, albumId, albumTags, albumArtist, albumSongList, albumLabel, albumYearReleased, albumCopies;
	private JButton submitAlbum, cancelAlbum;

	//Panels
	private JPanel addBook, addMovie, addVideoGame, addAlbum, cards;

	//Layouts
	private CardLayout cardLayout;

	//Final variables
	private static final long serialVersionUID = -1177073111608428671L;
	private static final int WIDTH = 320;
	private static final int HEIGHT = 315;

	public AddItemDialog( Frame parent, boolean modality, ItemLibrary lib, String itemType ) {
		super( parent, "Add Item", modality );

		this.lib = lib;
		init( itemType );

		super.setSize( WIDTH, HEIGHT );
		super.setLayout( new FlowLayout() );
		super.setLocationRelativeTo( parent );
		super.setVisible( true );
		super.setDefaultCloseOperation( JDialog.DISPOSE_ON_CLOSE );
	}

	/**
	 * Manage button actions
	 */
	public void actionPerformed( ActionEvent ae ) {
		Object o = ae.getSource();

		if( o == this.cancelVideoGame || o == this.cancelBook || o == this.cancelMovie || o == this.cancelAlbum ) {
			dispose();
		}
		else if( o == this.submitBook ) {
			//Get input
			try {
				String title = this.bookName.getText();
				String author = this.bookAuthor.getText();
				String genre = this.bookGenre.getText();
				String isbn = this.bookId.getText();
				String tagline = this.bookTags.getText();
				int copies = Integer.parseInt( this.bookCopies.getText() );
				String publisher = this.bookPublisher.getText();
				String yearPublished = this.bookYearPublished.getText();

				ArrayList<String> tags = parseTagline( tagline );

				//Validate input, add Book, save library, and close dialog
				if( validateYear( yearPublished) && copies >= 0 ) {
					lib.add( new Book( title, genre, isbn, copies, tags, author,  publisher, Integer.parseInt( yearPublished ) ) );
					lib.save();
					JOptionPane.showMessageDialog( this, "Successfully added book to library!", "Saved book successfully", JOptionPane.INFORMATION_MESSAGE );
					dispose();
				}
				else
					JOptionPane.showMessageDialog( this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
			} 
			catch ( NumberFormatException nfe ) {
				JOptionPane.showMessageDialog( this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( nfe );
			} 
			catch ( NullPointerException npe ) {
				JOptionPane.showMessageDialog( this, "Please check that all fields are filled out correctly.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( npe );
			}
		}
		else if( o == this.submitVideoGame ) {
			//Get input
			try {
				String title = this.videoGameName.getText();
				String genre = this.videoGameGenre.getText();
				String id = this.videoGameId.getText();
				String tagline = this.videoGameTags.getText();
				String console = this.videoGameConsole.getText();
				String developer = this.videoGameDeveloper.getText();
				String publisher = this.videoGamePublisher.getText();
				String contentRating = this.videoGameContentRating.getText();
				int copies = Integer.parseInt( this.videoGameCopies.getText() );

				ArrayList<String> tags = parseTagline( tagline );

				//Validate input, add VideoGame, save library, and close dialog
				if( copies >= 0 ) {
					lib.add( new VideoGame( title, genre, id, copies, tags, developer, publisher, console, contentRating ) );
					lib.save();
					JOptionPane.showMessageDialog( this, "Successfully added video game to library!", "Saved video game successfully", JOptionPane.INFORMATION_MESSAGE );
					dispose();
				}
				else
					JOptionPane.showMessageDialog( this, "Please ensure that your copies field is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
			}
			catch ( NumberFormatException nfe ) {
				JOptionPane.showMessageDialog( this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( nfe );
			} 
			catch ( NullPointerException npe ) {
				JOptionPane.showMessageDialog( this, "Please check that all fields are filled out correctly.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( npe );
			}
		}

		else if( o == this.submitMovie ) {
			//Get input
			try {
				String title = this.movieName.getText();
				String genre = this.movieGenre.getText();
				String id = movieId.getText();
				String tagline = movieTags.getText();
				int copies = Integer.parseInt( movieCopies.getText() );
				String director = movieDirector.getText();
				String rating = movieRating.getText();
				String starline = movieStars.getText();
				String yearReleased = movieYearReleased.getText();

				ArrayList<String> tags = parseTagline( tagline );
				ArrayList<String> stars = parseTagline( starline );

				//Validate input, add Movie, save library, and close dialog
				if(  validateYear( yearReleased ) && copies >= 0 ) {
					lib.add( new Movie( title, genre, id, copies, tags, director, rating, Integer.parseInt( yearReleased ), stars ) );
					lib.save();
					JOptionPane.showMessageDialog( this, "Successfully added movie to library!", "Saved movie successfully", JOptionPane.INFORMATION_MESSAGE );
					dispose();
				}
				else
					JOptionPane.showMessageDialog( this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
			}
			catch ( NumberFormatException nfe ) {
				JOptionPane.showMessageDialog( this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( nfe );
			} 
			catch ( NullPointerException npe ) {
				JOptionPane.showMessageDialog( this, "Please check that all fields are filled out correctly.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( npe );
			}
		}
		else if( o == this.submitAlbum ) {
			//Get input
			try {
				String name = albumName.getText();
				String genre = albumGenre.getText();
				String id = albumId.getText();
				String tagline = albumTags.getText();
				String artist = albumArtist.getText();
				String songline = albumSongList.getText();
				String label = albumLabel.getText();
				String yearReleased = albumYearReleased.getText();
				int copies = Integer.parseInt( albumCopies.getText() );

				ArrayList<String> tags = parseTagline( tagline );
				ArrayList<String> songList = parseTagline( songline );

				//Validate input, add Album, save library, and close dialog
				if(  validateYear( yearReleased ) && copies >= 0 ) {
					lib.add( new Album( name, genre, id, copies, tags, artist, label, songList, Integer.parseInt( yearReleased )  )  );
					lib.save();
					JOptionPane.showMessageDialog( this, "Successfully added movie to library!", "Saved movie successfully", JOptionPane.INFORMATION_MESSAGE );
					dispose();
				}
				else
					JOptionPane.showMessageDialog( this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
			}
			catch ( NumberFormatException nfe ) {
				JOptionPane.showMessageDialog( this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( nfe );
			} 
			catch ( NullPointerException npe ) {
				JOptionPane.showMessageDialog( this, "Please check that all fields are filled out correctly.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE );
				System.err.println( npe );
			}
		}
	}

	/**
	 * Parses lists formatted with semicolon delimiters and puts the individual Strings into an ArrayList
	 * @param tagline The formatted line
	 * @return The ArrayList containing the Strings
	 */
	private final ArrayList<String> parseTagline( String tagline ) {
		ArrayList<String> tags = new ArrayList<String>();
		Scanner tagParser = new Scanner( tagline );
		tagParser.useDelimiter( ";" );
		while( tagParser.hasNext() ) {
			String s = tagParser.next().toLowerCase();
			if( ! tags.contains( s ) )
				tags.add( s );
		}
		tagParser.close();

		return tags;
	}

	/**
	 * Validates a year using the Java implementation of regular expressions.
	 * 
	 * <p>Validates 4-digit dates. Prefix dates not using 4 digits with zeroes. For example, the year 93 would become 0093.</p>
	 * @param yearToValidate The year to valdiate
	 * @return If the specified year matches the specified regular expression pattern.
	 */
	private final boolean validateYear( String yearToValidate ) {
		return Pattern.matches( "\\d{4}", yearToValidate );
	}

	/**
	 * Initializes the AddBook panel
	 */
	private final void initAddBookPanel() {
		//buttons
		this.submitBook = new JButton( "Add book" );
		this.submitBook.addActionListener( this );
		this.cancelBook = new JButton( "Cancel" );
		this.cancelBook.addActionListener( this );

		//Text fields
		this.bookName = new JTextField( 12 );
		this.bookGenre = new JTextField( 12 ); 
		this.bookAuthor = new JTextField( 12 );
		this.bookId = new JTextField( 12 );
		this.bookTags = new JTextField( 12 );
		this.bookCopies = new JTextField( 12 );
		this.bookPublisher = new JTextField( 12 );
		this.bookYearPublished = new JTextField( 12 );
		this.bookTags.setToolTipText( "Separate with semicolons" );

		//Adding components
		this.addBook.add( new JLabel( "Title:" ) );
		this.addBook.add( this.bookName );
		this.addBook.add( new JLabel( "Author: " ) );
		this.addBook.add( this.bookAuthor );
		this.addBook.add( new JLabel( "Genre: " ) );
		this.addBook.add( this.bookGenre );
		this.addBook.add( new JLabel( "Publisher: " ) );
		this.addBook.add( this.bookPublisher );
		this.addBook.add( new JLabel( "Year published: " ) );
		this.addBook.add( this.bookYearPublished );
		this.addBook.add( new JLabel( "Tags: " ) );
		this.addBook.add( this.bookTags );
		this.addBook.add( new JLabel( "Copies: " ) );
		this.addBook.add( this.bookCopies );
		this.addBook.add( new JLabel( "ISBN: " ) );
		this.addBook.add( this.bookId );
		this.addBook.add( this.submitBook );
		this.addBook.add( this.cancelBook );
	}

	/**
	 * Initializes the AddMovie panel
	 */
	private final void initAddMoviePanel() {
		//Buttons
		this.submitMovie = new JButton( "Add movie" );
		this.submitMovie.addActionListener( this );
		this.cancelMovie = new JButton( "Cancel" );
		this.cancelMovie.addActionListener( this );

		//Text fields
		this.movieName = new JTextField( 12 );
		this.movieGenre = new JTextField( 12 );
		this.movieId = new JTextField( 12 );
		this.movieTags = new JTextField( 12 );
		this.movieCopies = new JTextField( 12 );
		this.movieDirector = new JTextField( 12 ); 
		this.movieRating = new JTextField( 12 );
		this.movieYearReleased = new JTextField( 12 );
		this.movieStars = new JTextField( 12 );
		this.movieTags.setToolTipText( "Separate with semicolons" );
		this.movieStars.setToolTipText( "Separate with semicolons" );

		//Adding components
		this.addMovie.add( new JLabel( "Title: " ) );
		this.addMovie.add( this.movieName );
		this.addMovie.add( new JLabel( "Director: " ) );
		this.addMovie.add( this.movieDirector );
		this.addMovie.add( new JLabel( "Genre: " ) );
		this.addMovie.add( this.movieGenre );
		this.addMovie.add( new JLabel( "Starring: " ) );
		this.addMovie.add( this.movieStars );
		this.addMovie.add( new JLabel( "Rating: " ) );
		this.addMovie.add( this.movieRating );
		this.addMovie.add( new JLabel( "Tags: " ) );
		this.addMovie.add( this.movieTags );
		this.addMovie.add( new JLabel( "Year released: " ) );
		this.addMovie.add( this.movieYearReleased );
		this.addMovie.add( new JLabel( "Copies: " ) );
		this.addMovie.add( this.movieCopies );
		this.addMovie.add( new JLabel( "ID:" ) );
		this.addMovie.add( this.movieId );
		this.addMovie.add( this.submitMovie );
		this.addMovie.add( this.cancelMovie );
	}

	/**
	 * Initializes the AddAlbum panel
	 */
	private final void initAddAlbumPanel() {
		//Buttons
		this.submitAlbum = new JButton( "Add album" );
		this.submitAlbum.addActionListener( this );
		this.cancelAlbum = new JButton( "Cancel" );
		this.cancelAlbum.addActionListener( this );

		//Text fields
		this.albumName = new JTextField( 12 );
		this.albumGenre = new JTextField( 12 );
		this.albumId = new JTextField( 12 );
		this.albumTags = new JTextField( 12 );
		this.albumArtist = new JTextField( 12 );
		this.albumSongList = new JTextField( 12 );
		this.albumLabel= new JTextField( 12 );
		this.albumYearReleased= new JTextField( 12 );
		this.albumCopies = new JTextField( 12 );
		this.albumTags.setToolTipText( "Separate with semicolons" );
		this.albumSongList.setToolTipText( "Separate with semicolons" );

		//Adding components
		this.addAlbum.add( new JLabel( "Title: " ) );
		this.addAlbum.add( this.albumName );
		this.addAlbum.add( new JLabel( "Artist: " ) );
		this.addAlbum.add( this.albumArtist );
		this.addAlbum.add( new JLabel( "Genre: " ) );
		this.addAlbum.add( this.albumGenre );
		this.addAlbum.add( new JLabel( "Label: " ) );
		this.addAlbum.add( this.albumLabel );
		this.addAlbum.add( new JLabel( "Song list: " ) );
		this.addAlbum.add( this.albumSongList );
		this.addAlbum.add( new JLabel( "Tags: " ) );
		this.addAlbum.add( this.albumTags );
		this.addAlbum.add( new JLabel( "Year released: " ) );
		this.addAlbum.add( this.albumYearReleased );
		this.addAlbum.add( new JLabel( "Copies: " ) );
		this.addAlbum.add( this.albumCopies );
		this.addAlbum.add( new JLabel( "ID: " ) );
		this.addAlbum.add( this.albumId );
		this.addAlbum.add( this.submitAlbum );
		this.addAlbum.add( this.cancelAlbum );
	}

	private final void initAddVideoGamePanel() {		
		//Buttons
		this.submitVideoGame = new JButton( "Add video game" );
		this.submitVideoGame.addActionListener( this );
		this.cancelVideoGame = new JButton( "Cancel" );
		this.cancelVideoGame.addActionListener( this );

		//Text fields
		this.videoGameName = new JTextField( 12 );
		this.videoGameGenre = new JTextField( 12 );
		this.videoGameId = new JTextField( 12 );
		this.videoGameTags = new JTextField( 12 );
		this.videoGameConsole = new JTextField( 12 );
		this.videoGameDeveloper = new JTextField( 12 );
		this.videoGamePublisher = new JTextField( 12 );
		this.videoGameContentRating = new JTextField( 12 );
		this.videoGameCopies = new JTextField( 12 );
		this.videoGameTags.setToolTipText(" Separate with semicolons" );

		//Adding components
		this.addVideoGame.add( new JLabel( "Title: " ) );
		this.addVideoGame.add( this.videoGameName );
		this.addVideoGame.add( new JLabel( "Genre: " ) );
		this.addVideoGame.add( this.videoGameGenre );
		this.addVideoGame.add( new JLabel( "Console: " ) );
		this.addVideoGame.add( this.videoGameConsole );
		this.addVideoGame.add( new JLabel( "Developer: " ) );
		this.addVideoGame.add( this.videoGameDeveloper );
		this.addVideoGame.add( new JLabel( "Publisher " ) );
		this.addVideoGame.add( this.videoGamePublisher);
		this.addVideoGame.add( new JLabel( "Content rating: " ) );
		this.addVideoGame.add( this.videoGameContentRating );
		this.addVideoGame.add( new JLabel( "Tags: " ) );
		this.addVideoGame.add( this.videoGameTags );
		this.addVideoGame.add( new JLabel( "Id: " ) );
		this.addVideoGame.add( this.videoGameId );
		this.addVideoGame.add( new JLabel( "Copies: " ) );
		this.addVideoGame.add( this.videoGameCopies );
		this.addVideoGame.add( this.submitVideoGame );
		this.addVideoGame.add( this.cancelVideoGame );
	}

	private final void init( String itemType ) {
		//Set up panels
		this.addBook = new JPanel( new GridLayout( 0, 2 ) );
		this.addMovie = new JPanel( new GridLayout( 0, 2 ) );
		this.addVideoGame = new JPanel( new GridLayout( 0, 2 ) );
		this.addAlbum = new JPanel( new GridLayout( 0, 2 ) );

		initAddBookPanel();
		initAddMoviePanel();
		initAddAlbumPanel();
		initAddVideoGamePanel();

		//Setup card layout
		this.cardLayout = new CardLayout();
		this.cards = new JPanel( this.cardLayout );
		this.cards.add( this.addBook, this.BOOK );
		this.cards.add( this.addMovie , this.MOVIE);
		this.cards.add( this.addVideoGame, this.VIDEOGAME );
		this.cards.add( this.addAlbum, this.ALBUM );

		this.cardLayout.show( this.cards, itemType.toLowerCase() );

		super.add( this.cards );
	}
}
</gui/dialogs/AddItemDialog.java>
ChatGPT said:
Reasoned about Java 17 code modernization for 15 seconds
We have seven files to modernize to Java 17. Some of the code is from Java 8 or earlier, with explicit generics, like new ArrayList<Item>()though some parts use the diamond operator. Ill refactor where possible using features like var (just for local variables), try-with-resources (especially for streams or in the load() method), and pattern matching for instanceof. Also, switch expressions could replace multiple if/else conditions in cases like the dialog code. Ill carefully consider each files structure for improvements.

In the ItemLibrary file, I can improve verifySaveFileLoc by using Files.createDirectories if necessary, but Ill need to check if its compatible with Java 17. For file saving, using try-with-resources should simplify things, and Ill apply that for file streams. Ill also look at using var for local variables and possibly text blocks for string constants. In method equals, Ill see if pattern matching for instanceof makes sense. Item and other files will be updated similarly, focusing on Java 17 features.

Below is one possible modernized version of your code using Java 17 features and style improvements. In the updated code we use:

 Trywithresources for file I/O (avoiding manual stream closing)
 The diamond operator (and in a few cases, the localvariable type inference viavar)
 Newer APIs from the NIO package (e.g. usingPaths andFiles.createDirectories)
 Pattern matching for instanceof (in the equals method)
 Some minor stringjoining improvements (for example, in toString methods)

You can review and adjust further as needed. For clarity, each files modernized version is given below.

File 1: ItemLibrary.java
java
Copy
Edit
package com.gizmo385.lm;

import java.io.EOFException;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import com.gizmo385.lm.types.Item;

/**
 * Manage a collection of Items and interface with them
 * @author Christopher
 */
public class ItemLibrary {

    private ArrayList<Item> library = new ArrayList<>();
    private final Path saveLocation;
    private final String libFileName = "library.dat";

    /**
     * Initializes the ItemLibrary
     */
    public ItemLibrary() {
        String userHome = System.getProperty("user.home");
        this.saveLocation = Paths.get(userHome, "gizmo385", "Library Manager");
        verifySaveFileLoc();
        System.out.println("Load status: " + load());
    }

    /**
     * Searches the tags of each item and returns matching Items.
     * @param tagToMatch The tag to match.
     * @return An ArrayList containing items that match the tag.
     */
    public ArrayList<Item> searchByTag(String tagToMatch) {
        var results = new ArrayList<Item>();
        for (Item i : library) {
            if (i.tagPresent(tagToMatch)) {
                results.add(i);
            }
        }
        return results;
    }

    /**
     * Clears out the library.
     */
    public boolean truncateLibrary() {
        this.library = new ArrayList<>();
        return save();
    }

    /**
     * Verifies the location of the save file.
     * Creates parent directories and the file itself if theyre not present.
     */
    private void verifySaveFileLoc() {
        try {
            Files.createDirectories(saveLocation);
            var filePath = saveLocation.resolve(libFileName);
            if (!Files.exists(filePath)) {
                Files.createFile(filePath);
            }
        } catch (IOException ioe) {
            System.err.println(ioe);
        }
    }

    /**
     * Saves the library to the designated save location.
     * @return The success or failure of the save operation.
     */
    public boolean save() {
        verifySaveFileLoc();
        var filePath = saveLocation.resolve(libFileName);
        try (var fos = new FileOutputStream(filePath.toFile());
             var oos = new ObjectOutputStream(fos)) {
            for (Item i : library) {
                oos.writeObject(i);
            }
            return true;
        } catch (IOException ioe) {
            return false;
        }
    }

    /**
     * Loads the library from the file located in the designated save location.
     * @return The success/failure of the load operation.
     */
    public boolean load() {
        verifySaveFileLoc();
        var filePath = saveLocation.resolve(libFileName);
        try (var fis = new FileInputStream(filePath.toFile());
             var ois = new ObjectInputStream(fis)) {
            library = new ArrayList<>();
            while (true) {
                library.add((Item) ois.readObject());
            }
        } catch (EOFException eof) {
            return true;
        } catch (IOException | ClassNotFoundException e) {
            System.err.println(e);
            return false;
        }
    }

    /**
     * Removes the specified item from the library.
     * @param item The item to remove.
     */
    public void deleteItem(Item item) {
        library.remove(item);
    }

    /**
     * Removes an item from the specified index.
     * @param index The index of the item to remove.
     */
    public void deleteItem(int index) {
        library.remove(index);
    }

    /**
     * Returns an item at a specified index.
     * @param index The index of the item to return.
     * @return The item at the specified index.
     */
    public Item getItem(int index) {
        return library.get(index);
    }

    /**
     * Adds an item to the library.
     * @param i The item to add.
     */
    public void add(Item i) {
        library.add(i);
    }

    /**
     * Returns a copy of the ArrayList.
     * @return A copy of the instance ArrayList.
     */
    public ArrayList<Item> getLibrary() {
        return new ArrayList<>(library);
    }
}
File 2: Album.java
java
Copy
Edit
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a music album.
 * @author Christopher
 */
public class Album extends Item {
    private static final long serialVersionUID = -6654556798874693337L;
    
    private String artist, label;
    private ArrayList<String> songs;
    private int yearReleased;

    public Album(String name, String genre, String id, int copies, ArrayList<String> tags, 
                 String artist, String label, ArrayList<String> songs, int yearReleased) {
        super("album", name, genre, id, copies, tags);
        this.artist = artist;
        this.label = label;
        this.songs = new ArrayList<>(songs);
        this.yearReleased = yearReleased;
    }

    public String getArtist() {
        return artist;
    }

    public String getLabel() {
        return label;
    }

    public ArrayList<String> getSongs() {
        return new ArrayList<>(songs);
    }

    public int getYearReleased() {
        return yearReleased;
    }

    public void setArtist(String artist) {
        this.artist = artist;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public void setSongs(ArrayList<String> songs) {
        this.songs = new ArrayList<>(songs);
    }

    public void setYearReleased(int yearReleased) {
        this.yearReleased = yearReleased;
    }

    @Override
    public String toString() {
        var lineSep = System.lineSeparator();
        // Using String.join to build the song list
        String songsList = String.join(", ", songs);
        return "Title: " + getName() + lineSep +
               "Artist: " + getArtist() + lineSep +
               "Music label: " + getLabel() + lineSep +
               "Music genre: " + getGenre() + lineSep +
               "Song list: " + songsList + lineSep +
               "Released in: " + getYearReleased() + lineSep;
    }

    @Override
    public boolean saveToFile(BufferedWriter fileOut) {
        var lineSep = System.lineSeparator();
        try {
            fileOut.write("[album]");
            fileOut.write(lineSep);
            fileOut.write(getName());
            fileOut.write(lineSep);
            fileOut.write(getGenre());
            fileOut.write(lineSep);
            fileOut.write(getId());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getCopies()));
            fileOut.write(lineSep);
            for (String s : getTags()) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
            fileOut.write(getArtist());
            fileOut.write(lineSep);
            fileOut.write(getLabel());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getYearReleased()));
            fileOut.write(lineSep);
            for (String s : getSongs()) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
        } catch (IOException ioe) {
            return false;
        }
        return true;
    }

    public static Item loadFromFile(Scanner fileScan) {
        String name = fileScan.nextLine();
        String genre = fileScan.nextLine();
        String id = fileScan.nextLine();
        int copies = Integer.parseInt(fileScan.nextLine());
        String tagLine = fileScan.nextLine();
        String artist = fileScan.nextLine();
        String label = fileScan.nextLine();
        int yearReleased = Integer.parseInt(fileScan.nextLine());
        String songLine = fileScan.nextLine();

        // Parse tags using split
        var tags = new ArrayList<String>();
        for (String token : tagLine.split(";")) {
            if (!token.isBlank()) {
                tags.add(token);
            }
        }

        // Parse song list
        var songs = new ArrayList<String>();
        for (String token : songLine.split(";")) {
            if (!token.isBlank()) {
                songs.add(token);
            }
        }

        return new Album(name, genre, id, copies, tags, artist, label, songs, yearReleased);
    }
}
File 3: Book.java
java
Copy
Edit
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a book.
 * @author Christopher
 */
public class Book extends Item {
    private static final long serialVersionUID = -120108029461760655L;
    
    private int yearPublished;
    private String author, publisher;
    
    public Book(String name, String genre, String id, int copies, ArrayList<String> tags, 
                String author, String publisher, int yearPublished) {
        super("book", name, genre, id, copies, tags);
        this.author = author;
        this.publisher = publisher;
        this.yearPublished = yearPublished;
        // Add necessary tags
        this.addTags(this.author, this.publisher);
    }
    
    public int getYearPublished() {
        return yearPublished;
    }

    public String getAuthor() {
        return author;
    }

    public String getPublisher() {
        return publisher;
    }

    public void setYearPublished(int yearPublished) {
        this.yearPublished = yearPublished;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public void setPublisher(String publisher) {
        this.publisher = publisher;
    }

    @Override
    public boolean saveToFile(BufferedWriter fileOut) {
        var lineSep = System.lineSeparator();
        try {
            fileOut.write("[book]");
            fileOut.write(lineSep);
            fileOut.write(getName());
            fileOut.write(lineSep);
            fileOut.write(getGenre());
            fileOut.write(lineSep);
            fileOut.write(getId());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getCopies()));
            fileOut.write(lineSep);
            for (String s : getTags()) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
            fileOut.write(getAuthor());
            fileOut.write(lineSep);
            fileOut.write(getPublisher());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getYearPublished()));
            fileOut.write(lineSep);
        } catch (IOException ioe) {
            return false;
        }
        return true;
    }

    public static Item loadFromFile(Scanner fileScan) {
        try {
            String name = fileScan.nextLine();
            String genre = fileScan.nextLine();
            String id = fileScan.nextLine();
            int copies = Integer.parseInt(fileScan.nextLine());
            String tagLine = fileScan.nextLine();
            String author = fileScan.nextLine();
            String publisher = fileScan.nextLine();
            int yearPublished = Integer.parseInt(fileScan.nextLine());
            
            var tags = new ArrayList<String>();
            for (String token : tagLine.split(";")) {
                if (!token.isBlank()) {
                    tags.add(token);
                }
            }
            
            return new Book(name, genre, id, copies, tags, author, publisher, yearPublished);
        } catch (NumberFormatException e) {
            System.err.println("Error loading book: " + e);
            return null;
        }
    }

    @Override
    public String toString() {
        var lineSep = System.lineSeparator();
        return "Name: " + getName() + lineSep +
               "Author: " + getAuthor() + lineSep +
               "Genre: " + getGenre() + lineSep +
               "Published in " + getYearPublished() + " by " + getPublisher() + lineSep +
               "Copies owned: " + getCopies() + lineSep +
               "ISBN: " + getId() + lineSep;
    }
}
File 4: Item.java
java
Copy
Edit
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.Serializable;
import java.util.ArrayList;

/**
 * Abstract class representing an Item. Superclass to all other items.
 * @author Christopher
 */
public abstract class Item implements Comparable<Item>, Serializable {
    private static final long serialVersionUID = -2518470675811167937L;
    
    private final String ITEM_TYPE;
    private String name, genre, id;
    private int copies;
    private ArrayList<String> tags;

    /**
     * Constructor for the abstract Item class.
     * @param itemType The type of item extending this abstract class.
     * @param name The name of this item.
     * @param genre The genre of this item.
     * @param id This item's ID.
     * @param copies The number of copies of this item in inventory.
     * @param tags Words associated with this item for searching.
     */
    public Item(String itemType, String name, String genre, String id, int copies, ArrayList<String> tags) {
        this.ITEM_TYPE = itemType.toLowerCase();
        this.name = name;
        this.genre = genre;
        this.id = id;
        this.copies = Math.max(copies, 0);
        this.tags = new ArrayList<>();
        for (String s : tags) {
            if (!this.tags.contains(s.toLowerCase())) {
                this.tags.add(s.toLowerCase());
            }
        }
        if (!this.tags.contains(this.name.toLowerCase()))
            this.tags.add(this.name.toLowerCase());
        if (!this.tags.contains(this.genre.toLowerCase()))
            this.tags.add(this.genre.toLowerCase());
        if (!this.tags.contains(this.id.toLowerCase()))
            this.tags.add(this.id.toLowerCase());
        if (!this.tags.contains(this.ITEM_TYPE.toLowerCase()))
            this.tags.add(this.ITEM_TYPE.toLowerCase());
    }
    
    public String getName() {
        return name;
    }
    
    public String getItemType() {
        return ITEM_TYPE;
    }

    public String getGenre() {
        return genre;
    }

    public String getId() {
        return id;
    }

    public int getCopies() {
        return copies;
    }

    public ArrayList<String> getTags() {
        return new ArrayList<>(tags);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setGenre(String genre) {
        this.genre = genre;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setCopies(int copies) {
        this.copies = copies;
    }

    public void setTags(ArrayList<String> tags) {
        this.tags = new ArrayList<>();
        for (String s : tags) {
            if (!this.tags.contains(s.toLowerCase())) {
                this.tags.add(s.toLowerCase());
            }
        }
        if (!this.tags.contains(this.name.toLowerCase()))
            this.tags.add(this.name.toLowerCase());
        if (!this.tags.contains(this.genre.toLowerCase()))
            this.tags.add(this.genre.toLowerCase());
        if (!this.tags.contains(this.id.toLowerCase()))
            this.tags.add(this.id.toLowerCase());
    }
    
    public boolean addTag(String tag) {
        return !tagPresent(tag) && tags.add(tag.toLowerCase());
    }
    
    public void addTags(String... tags) {
        for (String tag : tags) {
            addTag(tag);
        }
    }
    
    public boolean removeTag(String tag) {
        return tagPresent(tag) && tags.remove(tag.toLowerCase());
    }
    
    public boolean tagPresent(String tag) {
        return tags.contains(tag.toLowerCase());
    }
    
    @Override
    public int compareTo(Item i) {
        return name.compareTo(i.getName());
    }
    
    @Override
    public boolean equals(Object o) {
        if (o instanceof Item i) {
            return this.name.equals(i.getName()) && this.genre.equals(i.getGenre()) && this.id.equals(i.getId());
        }
        return false;
    }
    
    @Override
    public abstract String toString();
    
    /**
     * Saves this item to the file associated with fileOut.
     * @param fileOut The BufferedWriter that is writing to the save file.
     * @return The success/failure of the save operation for this Item.
     */
    public abstract boolean saveToFile(BufferedWriter fileOut);
}
File 5: Movie.java
java
Copy
Edit
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a Movie.
 * @author Christopher
 */
public class Movie extends Item {
    private static final long serialVersionUID = -4801301178032374860L;
    
    private String director, rating;
    private int yearReleased;
    private ArrayList<String> stars;

    public Movie(String name, String genre, String id, int copies, ArrayList<String> tags,
                 String director, String rating, int yearReleased, ArrayList<String> stars) {
        super("movie", name, genre, id, copies, tags);
        this.director = director;
        this.rating = rating;
        this.yearReleased = yearReleased;
        this.stars = new ArrayList<>(stars);
    }

    public String getDirector() {
        return director;
    }

    public String getRating() {
        return rating;
    }

    public int getYearReleased() {
        return yearReleased;
    }

    public ArrayList<String> getStars() {
        return new ArrayList<>(stars);
    }

    public void setDirector(String director) {
        this.director = director;
    }

    public void setRating(String rating) {
        this.rating = rating;
    }

    public void setYearReleased(int yearReleased) {
        this.yearReleased = yearReleased;
    }

    public void setStars(ArrayList<String> stars) {
        this.stars = new ArrayList<>(stars);
    }

    @Override
    public String toString() {
        var lineSep = System.lineSeparator();
        String starsList = String.join(", ", stars);
        return "Title: " + getName() + lineSep +
               "Director: " + getDirector() + lineSep +
               "Starring: " + starsList + lineSep +
               "Genre: " + getGenre() + lineSep +
               "Rated: " + getRating() + lineSep +
               "Released in " + getYearReleased() + lineSep;
    }

    @Override
    public boolean saveToFile(BufferedWriter fileOut) {
        var lineSep = System.lineSeparator();
        try {
            fileOut.write("[movie]");
            fileOut.write(lineSep);
            fileOut.write(getName());
            fileOut.write(lineSep);
            fileOut.write(getGenre());
            fileOut.write(lineSep);
            fileOut.write(getId());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getCopies()));
            fileOut.write(lineSep);
            for (String s : getTags()) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
            fileOut.write(getDirector());
            fileOut.write(lineSep);
            fileOut.write(getRating());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getYearReleased()));
            fileOut.write(lineSep);
            for (String s : stars) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
        } catch (IOException ioe) {
            return false;
        }
        return true;
    }

    public static Item loadFromFile(Scanner fileScan) {
        String name = fileScan.nextLine();
        String genre = fileScan.nextLine();
        String id = fileScan.nextLine();
        int copies = Integer.parseInt(fileScan.nextLine());
        String tagLine = fileScan.nextLine();
        String director = fileScan.nextLine();
        String rating = fileScan.nextLine();
        int yearReleased = Integer.parseInt(fileScan.nextLine());
        String starsLine = fileScan.nextLine();

        var tags = new ArrayList<String>();
        for (String token : tagLine.split(";")) {
            if (!token.isBlank()) {
                tags.add(token);
            }
        }

        var stars = new ArrayList<String>();
        for (String token : starsLine.split(";")) {
            if (!token.isBlank()) {
                stars.add(token);
            }
        }
        
        return new Movie(name, genre, id, copies, tags, director, rating, yearReleased, stars);
    }
}
File 6: VideoGame.java
java
Copy
Edit
package com.gizmo385.lm.types;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a video game.
 * (c) Christopher
 */
public class VideoGame extends Item {
    private static final long serialVersionUID = -6305473299083489814L;
    
    private String developer, publisher, console, contentRating;
    
    public VideoGame(String name, String genre, String id, int copies, ArrayList<String> tags,
                     String developer, String publisher, String console, String contentRating) {
        super("video game", name, genre, id, copies, tags);
        this.developer = developer;
        this.publisher = publisher;
        this.console = console;
        this.contentRating = contentRating;
        this.addTags(developer, publisher, console, contentRating);
    }
    
    public String getDeveloper() {
        return developer;
    }

    public String getPublisher() {
        return publisher;
    }

    public String getConsole() {
        return console;
    }

    public String getContentRating() {
        return contentRating;
    }

    public void setDeveloper(String developer) {
        this.developer = developer;
    }

    public void setPublisher(String publisher) {
        this.publisher = publisher;
    }
    
    public void setConsole(String console) {
        this.console = console;
    }

    public void setContentRating(String contentRating) {
        this.contentRating = contentRating;
    }

    @Override
    public boolean saveToFile(BufferedWriter fileOut) {
        var lineSep = System.lineSeparator();
        try {
            fileOut.write("[videogame]");
            fileOut.write(lineSep);
            fileOut.write(getName());
            fileOut.write(lineSep);
            fileOut.write(getGenre());
            fileOut.write(lineSep);
            fileOut.write(getId());
            fileOut.write(lineSep);
            fileOut.write(String.valueOf(getCopies()));
            fileOut.write(lineSep);
            for (String s : getTags()) {
                fileOut.write(s + ";");
            }
            fileOut.write(lineSep);
            fileOut.write(getDeveloper());
            fileOut.write(lineSep);
            fileOut.write(getPublisher());
            fileOut.write(lineSep);
            fileOut.write(getConsole());
            fileOut.write(lineSep);
            fileOut.write(getContentRating());
            fileOut.write(lineSep);
        } catch (IOException ioe) {
            return false;
        }
        return true;
    }

    public static Item loadFromFile(Scanner fileScan) {
        String name = fileScan.nextLine();
        String genre = fileScan.nextLine();
        String id = fileScan.nextLine();
        int copies = Integer.parseInt(fileScan.nextLine());
        String tagLine = fileScan.nextLine();
        String developer = fileScan.nextLine();
        String publisher = fileScan.nextLine();
        String console = fileScan.nextLine();
        String contentRating = fileScan.nextLine();
        
        var tags = new ArrayList<String>();
        for (String token : tagLine.split(";")) {
            if (!token.isBlank()) {
                tags.add(token);
            }
        }
        
        return new VideoGame(name, genre, id, copies, tags, developer, publisher, console, contentRating);
    }

    @Override
    public String toString() {
        var lineSep = System.lineSeparator();
        return "Title: " + getName() + lineSep +
               "Genre: " + getGenre() + lineSep +
               "Developer: " + getDeveloper() + lineSep +
               "Publisher: " + getPublisher() + lineSep +
               "Console: " + getConsole() + lineSep +
               "Rating: " + getContentRating() + lineSep +
               "Copies owned: " + getCopies() + lineSep;
    }
}
File 7: LibraryManagerFrame.java
java
Copy
Edit
package com.gizmo385.lm.gui;

import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.ArrayList;
import java.util.HashMap;

import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import com.gizmo385.lm.ItemLibrary;
import com.gizmo385.lm.gui.dialogs.AddItemDialog;
import com.gizmo385.lm.types.Item;

/**
 * Primary window for the Library Manager.
 * Allows the user to interact with their library.
 * Selecting items from the JList displays their full details.
 * Search capabilities are provided so that the user can search for items by tags.
 * 
 * (c) Christopher
 */
public class LibraryManagerFrame extends JFrame implements ActionListener, ListSelectionListener, ItemListener, WindowListener {

    private ItemLibrary library;
    private HashMap<String, Item> titlesToItems;
    private DefaultListModel<String> defaultListModel, currentListModel;
    
    private AddItemDialog aid;

    private JList<String> itemsDisplaying;
    private JTextArea detailedItemDisplay;
    private JTextField searchQuery;
    private JButton search, cancel, deleteSelectedItems;
    private JScrollPane listScrollPane, textAreaScrollPane;
    private JComboBox<String> itemSelection;

    private static final long serialVersionUID = -8264093334345119816L;
    private static final int WIDTH = 535;
    private static final int HEIGHT = 430;

    public LibraryManagerFrame() {
        super("Library Manager");
        init();
        setSize(WIDTH, HEIGHT);
        setLayout(new FlowLayout());
        setVisible(true);
        setResizable(false);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    /**
     * Loads library entries into the DefaultListModel and displays them.
     */
    private void reloadLibraryEntries() {
        library = new ItemLibrary();
        titlesToItems = new HashMap<>();
        defaultListModel = new DefaultListModel<>();
        for (Item i : library.getLibrary()) {
            defaultListModel.addElement(i.getName());
            titlesToItems.put(i.getName(), i);
        }
        currentListModel = defaultListModel;
    }

    private void init() {
        reloadLibraryEntries();

        itemsDisplaying = new JList<>(defaultListModel);
        itemsDisplaying.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        itemsDisplaying.setToolTipText("Select items here for detailed representations to the right.");
        itemsDisplaying.addListSelectionListener(this); 

        detailedItemDisplay = new JTextArea(20, 22);
        detailedItemDisplay.setEditable(false);
        detailedItemDisplay.setToolTipText("Items selected to the left will display here.");

        listScrollPane = new JScrollPane(itemsDisplaying);
        listScrollPane.setBorder(BorderFactory.createTitledBorder("Items in the library: "));
        listScrollPane.setPreferredSize(new Dimension(250, 345));

        textAreaScrollPane = new JScrollPane(detailedItemDisplay);
        textAreaScrollPane.setBorder(BorderFactory.createTitledBorder("Items currently selected: "));

        searchQuery = new JTextField(15);
        searchQuery.addActionListener(this);

        search = new JButton("Search");
        search.addActionListener(this);
        
        deleteSelectedItems = new JButton("Delete");
        deleteSelectedItems.addActionListener(this);
        
        cancel = new JButton("Cancel");
        cancel.addActionListener(this);
        
        itemSelection = new JComboBox<>();
        itemSelection.addItem("---Add Item---");
        itemSelection.addItem("Book");
        itemSelection.addItem("Video Game");
        itemSelection.addItem("Album");
        itemSelection.addItem("Movie");
        itemSelection.addItemListener(this);
        
        add(listScrollPane);
        add(textAreaScrollPane);
        add(searchQuery);
        add(search);
        add(cancel);
        add(itemSelection);
        add(deleteSelectedItems);
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        if (ae.getSource() == searchQuery || ae.getSource() == search) {
            ArrayList<Item> results = library.searchByTag(searchQuery.getText());
            currentListModel = new DefaultListModel<>();
            for (Item i : results) {
                currentListModel.addElement(i.getName());
            }
            itemsDisplaying.setModel(currentListModel);
        } else if (ae.getSource() == cancel) {
            searchQuery.setText("");
            detailedItemDisplay.setText("");
            itemsDisplaying.setModel(defaultListModel);
            currentListModel = defaultListModel;
        } else if (ae.getSource() == deleteSelectedItems) {
            int[] selected = itemsDisplaying.getSelectedIndices();
            if (selected.length == 0) {
                JOptionPane.showMessageDialog(this, "No items have been selected.", "No items selected.", JOptionPane.ERROR_MESSAGE);
            } else {
                int confirmation = JOptionPane.showConfirmDialog(this, "Are you sure you wish to delete " + selected.length + " item(s) from the library?", "Confirm deletion.", JOptionPane.YES_NO_OPTION);
                if (confirmation == JOptionPane.YES_OPTION) {
                    for (int i : selected) {
                        library.deleteItem(titlesToItems.get(currentListModel.get(i)));
                    }
                    library.save();
                    library.load();
                    reloadLibraryEntries();
                    itemsDisplaying.setModel(defaultListModel);
                }
            }
        }
    }

    @Override
    public void valueChanged(ListSelectionEvent ise) {
        if (ise.getSource() == itemsDisplaying) {
            detailedItemDisplay.setText("");
            int[] selected = itemsDisplaying.getSelectedIndices();
            for (int i : selected) {
                detailedItemDisplay.append(titlesToItems.get(currentListModel.get(i)).toString() + System.lineSeparator());
            }
        }
    }
    
    @Override
    public void itemStateChanged(ItemEvent ie) {
        if (ie.getSource() == itemSelection && ie.getStateChange() == ItemEvent.SELECTED) {
            String s = (String) itemSelection.getSelectedItem();
            // Using switch expression available in Java 17
            switch (s.toLowerCase()) {
                case "book" -> {
                    aid = new AddItemDialog(this, true, library, "book");
                    aid.addWindowListener(this);
                }
                case "album" -> {
                    aid = new AddItemDialog(this, true, library, "album");
                    aid.addWindowListener(this);
                }
                case "movie" -> {
                    aid = new AddItemDialog(this, true, library, "movie");
                    aid.addWindowListener(this);
                }
                case "video game" -> {
                    aid = new AddItemDialog(this, true, library, "videogame");
                    aid.addWindowListener(this);
                }
                default -> {
                    // Do nothing
                }
            }
        }
    }

    @Override
    public void windowActivated(WindowEvent e) { }

    @Override
    public void windowClosed(WindowEvent e) { 
        reloadLibraryEntries();
        itemsDisplaying.setModel(defaultListModel);
    }

    @Override
    public void windowClosing(WindowEvent e) { 
        reloadLibraryEntries();
        itemsDisplaying.setModel(defaultListModel);
    }

    @Override
    public void windowDeactivated(WindowEvent e) { }

    @Override
    public void windowDeiconified(WindowEvent e) { }

    @Override
    public void windowIconified(WindowEvent e) { }

    @Override
    public void windowOpened(WindowEvent e) { }

    public static void main(String[] args) {
        new LibraryManagerFrame();
    }
}
File 8: AddItemDialog.java
java
Copy
Edit
package com.gizmo385.lm.gui.dialogs;

import java.awt.CardLayout;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.regex.Pattern;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

import com.gizmo385.lm.ItemLibrary;
import com.gizmo385.lm.types.Album;
import com.gizmo385.lm.types.Book;
import com.gizmo385.lm.types.Movie;
import com.gizmo385.lm.types.VideoGame;

/**
 * This dialog is used to add items to the library.
 * (c) Christopher
 */
public class AddItemDialog extends JDialog implements ActionListener {
    ItemLibrary lib;

    // Item types
    private final String BOOK = "book";
    private final String MOVIE = "movie";
    private final String ALBUM = "album";
    private final String VIDEOGAME = "videogame";

    // addBook components
    private JTextField bookName, bookGenre, bookAuthor, bookId, bookTags, bookCopies, bookPublisher, bookYearPublished;
    private JButton submitBook, cancelBook;

    // addMovie components
    private JTextField movieName, movieGenre, movieId, movieTags, movieCopies, movieDirector, movieRating, movieStars, movieYearReleased;
    private JButton submitMovie, cancelMovie;

    // addVideoGame components
    private JTextField videoGameName, videoGameGenre, videoGameId, videoGameTags, videoGameConsole, videoGameDeveloper, videoGamePublisher, videoGameContentRating, videoGameCopies;
    private JButton submitVideoGame, cancelVideoGame;

    // addAlbum components
    private JTextField albumName, albumGenre, albumId, albumTags, albumArtist, albumSongList, albumLabel, albumYearReleased, albumCopies;
    private JButton submitAlbum, cancelAlbum;

    // Panels
    private JPanel addBook, addMovie, addVideoGame, addAlbum, cards;

    // Layouts
    private CardLayout cardLayout;

    private static final long serialVersionUID = -1177073111608428671L;
    private static final int WIDTH = 320;
    private static final int HEIGHT = 315;

    public AddItemDialog(Frame parent, boolean modality, ItemLibrary lib, String itemType) {
        super(parent, "Add Item", modality);
        this.lib = lib;
        init(itemType);
        setSize(WIDTH, HEIGHT);
        setLayout(new FlowLayout());
        setLocationRelativeTo(parent);
        setVisible(true);
        setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Object o = ae.getSource();

        if (o == cancelVideoGame || o == cancelBook || o == cancelMovie || o == cancelAlbum) {
            dispose();
        } else if (o == submitBook) {
            try {
                String title = bookName.getText();
                String author = bookAuthor.getText();
                String genre = bookGenre.getText();
                String isbn = bookId.getText();
                String tagline = bookTags.getText();
                int copies = Integer.parseInt(bookCopies.getText());
                String publisher = bookPublisher.getText();
                String yearPublished = bookYearPublished.getText();

                ArrayList<String> tags = parseTagline(tagline);

                if (validateYear(yearPublished) && copies >= 0) {
                    lib.add(new Book(title, genre, isbn, copies, tags, author, publisher, Integer.parseInt(yearPublished)));
                    lib.save();
                    JOptionPane.showMessageDialog(this, "Successfully added book to library!", "Saved book successfully", JOptionPane.INFORMATION_MESSAGE);
                    dispose();
                } else {
                    JOptionPane.showMessageDialog(this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                }
            } catch (NumberFormatException nfe) {
                JOptionPane.showMessageDialog(this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                System.err.println(nfe);
            }
        } else if (o == submitVideoGame) {
            try {
                String title = videoGameName.getText();
                String genre = videoGameGenre.getText();
                String id = videoGameId.getText();
                String tagline = videoGameTags.getText();
                String console = videoGameConsole.getText();
                String developer = videoGameDeveloper.getText();
                String publisher = videoGamePublisher.getText();
                String contentRating = videoGameContentRating.getText();
                int copies = Integer.parseInt(videoGameCopies.getText());

                ArrayList<String> tags = parseTagline(tagline);

                if (copies >= 0) {
                    lib.add(new VideoGame(title, genre, id, copies, tags, developer, publisher, console, contentRating));
                    lib.save();
                    JOptionPane.showMessageDialog(this, "Successfully added video game to library!", "Saved video game successfully", JOptionPane.INFORMATION_MESSAGE);
                    dispose();
                } else {
                    JOptionPane.showMessageDialog(this, "Please ensure that your copies field is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                }
            } catch (NumberFormatException nfe) {
                JOptionPane.showMessageDialog(this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                System.err.println(nfe);
            }
        } else if (o == submitMovie) {
            try {
                String title = movieName.getText();
                String genre = movieGenre.getText();
                String id = movieId.getText();
                String tagline = movieTags.getText();
                int copies = Integer.parseInt(movieCopies.getText());
                String director = movieDirector.getText();
                String rating = movieRating.getText();
                String starline = movieStars.getText();
                String yearReleased = movieYearReleased.getText();

                ArrayList<String> tags = parseTagline(tagline);
                ArrayList<String> stars = parseTagline(starline);

                if (validateYear(yearReleased) && copies >= 0) {
                    lib.add(new Movie(title, genre, id, copies, tags, director, rating, Integer.parseInt(yearReleased), stars));
                    lib.save();
                    JOptionPane.showMessageDialog(this, "Successfully added movie to library!", "Saved movie successfully", JOptionPane.INFORMATION_MESSAGE);
                    dispose();
                } else {
                    JOptionPane.showMessageDialog(this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                }
            } catch (NumberFormatException nfe) {
                JOptionPane.showMessageDialog(this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                System.err.println(nfe);
            }
        } else if (o == submitAlbum) {
            try {
                String name = albumName.getText();
                String genre = albumGenre.getText();
                String id = albumId.getText();
                String tagline = albumTags.getText();
                String artist = albumArtist.getText();
                String songline = albumSongList.getText();
                String label = albumLabel.getText();
                String yearReleased = albumYearReleased.getText();
                int copies = Integer.parseInt(albumCopies.getText());

                ArrayList<String> tags = parseTagline(tagline);
                ArrayList<String> songList = parseTagline(songline);

                if (validateYear(yearReleased) && copies >= 0) {
                    lib.add(new Album(name, genre, id, copies, tags, artist, label, songList, Integer.parseInt(yearReleased)));
                    lib.save();
                    JOptionPane.showMessageDialog(this, "Successfully added album to library!", "Saved album successfully", JOptionPane.INFORMATION_MESSAGE);
                    dispose();
                } else {
                    JOptionPane.showMessageDialog(this, "Please ensure that your copies field and that your 4-digit year is valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                }
            } catch (NumberFormatException nfe) {
                JOptionPane.showMessageDialog(this, "Please check that the numbers you have entered are valid.", "Error! - Library Manager - Add Item", JOptionPane.ERROR_MESSAGE);
                System.err.println(nfe);
            }
        }
    }

    /**
     * Parses a semicolon-delimited string into an ArrayList of tags.
     */
    private ArrayList<String> parseTagline(String tagline) {
        var tags = new ArrayList<String>();
        for (String token : tagline.split(";")) {
            String s = token.toLowerCase().trim();
            if (!s.isBlank() && !tags.contains(s)) {
                tags.add(s);
            }
        }
        return tags;
    }

    /**
     * Validates a year string (exactly 4 digits).
     */
    private boolean validateYear(String yearToValidate) {
        return Pattern.matches("\\d{4}", yearToValidate);
    }

    private void initAddBookPanel() {
        submitBook = new JButton("Add book");
        submitBook.addActionListener(this);
        cancelBook = new JButton("Cancel");
        cancelBook.addActionListener(this);

        bookName = new JTextField(12);
        bookGenre = new JTextField(12); 
        bookAuthor = new JTextField(12);
        bookId = new JTextField(12);
        bookTags = new JTextField(12);
        bookCopies = new JTextField(12);
        bookPublisher = new JTextField(12);
        bookYearPublished = new JTextField(12);
        bookTags.setToolTipText("Separate with semicolons");

        addBook.add(new JLabel("Title:"));
        addBook.add(bookName);
        addBook.add(new JLabel("Author:"));
        addBook.add(bookAuthor);
        addBook.add(new JLabel("Genre:"));
        addBook.add(bookGenre);
        addBook.add(new JLabel("Publisher:"));
        addBook.add(bookPublisher);
        addBook.add(new JLabel("Year published:"));
        addBook.add(bookYearPublished);
        addBook.add(new JLabel("Tags:"));
        addBook.add(bookTags);
        addBook.add(new JLabel("Copies:"));
        addBook.add(bookCopies);
        addBook.add(new JLabel("ISBN:"));
        addBook.add(bookId);
        addBook.add(submitBook);
        addBook.add(cancelBook);
    }

    private void initAddMoviePanel() {
        submitMovie = new JButton("Add movie");
        submitMovie.addActionListener(this);
        cancelMovie = new JButton("Cancel");
        cancelMovie.addActionListener(this);

        movieName = new JTextField(12);
        movieGenre = new JTextField(12);
        movieId = new JTextField(12);
        movieTags = new JTextField(12);
        movieCopies = new JTextField(12);
        movieDirector = new JTextField(12); 
        movieRating = new JTextField(12);
        movieYearReleased = new JTextField(12);
        movieStars = new JTextField(12);
        movieTags.setToolTipText("Separate with semicolons");
        movieStars.setToolTipText("Separate with semicolons");

        addMovie.add(new JLabel("Title:"));
        addMovie.add(movieName);
        addMovie.add(new JLabel("Director:"));
        addMovie.add(movieDirector);
        addMovie.add(new JLabel("Genre:"));
        addMovie.add(movieGenre);
        addMovie.add(new JLabel("Starring:"));
        addMovie.add(movieStars);
        addMovie.add(new JLabel("Rating:"));
        addMovie.add(movieRating);
        addMovie.add(new JLabel("Tags:"));
        addMovie.add(movieTags);
        addMovie.add(new JLabel("Year released:"));
        addMovie.add(movieYearReleased);
        addMovie.add(new JLabel("Copies:"));
        addMovie.add(movieCopies);
        addMovie.add(new JLabel("ID:"));
        addMovie.add(movieId);
        addMovie.add(submitMovie);
        addMovie.add(cancelMovie);
    }

    private void initAddAlbumPanel() {
        submitAlbum = new JButton("Add album");
        submitAlbum.addActionListener(this);
        cancelAlbum = new JButton("Cancel");
        cancelAlbum.addActionListener(this);

        albumName = new JTextField(12);
        albumGenre = new JTextField(12);
        albumId = new JTextField(12);
        albumTags = new JTextField(12);
        albumArtist = new JTextField(12);
        albumSongList = new JTextField(12);
        albumLabel = new JTextField(12);
        albumYearReleased = new JTextField(12);
        albumCopies = new JTextField(12);
        albumTags.setToolTipText("Separate with semicolons");
        albumSongList.setToolTipText("Separate with semicolons");

        addAlbum.add(new JLabel("Title:"));
        addAlbum.add(albumName);
        addAlbum.add(new JLabel("Artist:"));
        addAlbum.add(albumArtist);
        addAlbum.add(new JLabel("Genre:"));
        addAlbum.add(albumGenre);
        addAlbum.add(new JLabel("Label:"));
        addAlbum.add(albumLabel);
        addAlbum.add(new JLabel("Song list:"));
        addAlbum.add(albumSongList);
        addAlbum.add(new JLabel("Tags:"));
        addAlbum.add(albumTags);
        addAlbum.add(new JLabel("Year released:"));
        addAlbum.add(albumYearReleased);
        addAlbum.add(new JLabel("Copies:"));
        addAlbum.add(albumCopies);
        addAlbum.add(new JLabel("ID:"));
        addAlbum.add(albumId);
        addAlbum.add(submitAlbum);
        addAlbum.add(cancelAlbum);
    }

    private void initAddVideoGamePanel() {
        submitVideoGame = new JButton("Add video game");
        submitVideoGame.addActionListener(this);
        cancelVideoGame = new JButton("Cancel");
        cancelVideoGame.addActionListener(this);

        videoGameName = new JTextField(12);
        videoGameGenre = new JTextField(12);
        videoGameId = new JTextField(12);
        videoGameTags = new JTextField(12);
        videoGameConsole = new JTextField(12);
        videoGameDeveloper = new JTextField(12);
        videoGamePublisher = new JTextField(12);
        videoGameContentRating = new JTextField(12);
        videoGameCopies = new JTextField(12);
        videoGameTags.setToolTipText("Separate with semicolons");

        addVideoGame.add(new JLabel("Title:"));
        addVideoGame.add(videoGameName);
        addVideoGame.add(new JLabel("Genre:"));
        addVideoGame.add(videoGameGenre);
        addVideoGame.add(new JLabel("Console:"));
        addVideoGame.add(videoGameConsole);
        addVideoGame.add(new JLabel("Developer:"));
        addVideoGame.add(videoGameDeveloper);
        addVideoGame.add(new JLabel("Publisher:"));
        addVideoGame.add(videoGamePublisher);
        addVideoGame.add(new JLabel("Content rating:"));
        addVideoGame.add(videoGameContentRating);
        addVideoGame.add(new JLabel("Tags:"));
        addVideoGame.add(videoGameTags);
        addVideoGame.add(new JLabel("ID:"));
        addVideoGame.add(videoGameId);
        addVideoGame.add(new JLabel("Copies:"));
        addVideoGame.add(videoGameCopies);
        addVideoGame.add(submitVideoGame);
        addVideoGame.add(cancelVideoGame);
    }

    private void init(String itemType) {
        addBook = new JPanel(new GridLayout(0, 2));
        addMovie = new JPanel(new GridLayout(0, 2));
        addVideoGame = new JPanel(new GridLayout(0, 2));
        addAlbum = new JPanel(new GridLayout(0, 2));

        initAddBookPanel();
        initAddMoviePanel();
        initAddAlbumPanel();
        initAddVideoGamePanel();

        cardLayout = new CardLayout();
        cards = new JPanel(cardLayout);
        cards.add(addBook, BOOK);
        cards.add(addMovie, MOVIE);
        cards.add(addVideoGame, VIDEOGAME);
        cards.add(addAlbum, ALBUM);

        cardLayout.show(cards, itemType.toLowerCase());
        add(cards);
    }
}
This revised code leverages modern Java 17 practices while keeping the original structure and behavior. You may adjust further as needed for your project requirements.