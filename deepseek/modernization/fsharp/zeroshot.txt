Modernize the code to Java Version 17

File 1:
<phokUi.java>
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import javax.swing.event.*;
import java.sql.*;
import java.io.*;

public class PhokUi {
	static JList artists,albums,tracks;
	static TextField dir;
	static Button scan;
	static String msg;
	static Connection conn;	
	static String driver;
	static String url;
	static String db;
	static String user;
	static String pass;
	static JScrollPane artistPanel;
	static JScrollPane albumPanel;
	static JScrollPane trackPanel;
	static ResultSet rs;
	static DefaultListModel artistModel, albumModel, trackModel;
	static JFrame window;
	static JLabel status;
	static Statement populate, popAlbum, popTrack;

	public static void main(String[] args) throws SQLException{
		try {
			driver = new String();
			driver = "com.mysql.jdbc.Driver";
			url = new String();
			url = "jdbc:mysql://localhost/";
			db = new String();
			db = "music";
			user = new String();
			user = "phoku";
			pass = new String();
			pass = "phoku";
			JPanel contentPane = new JPanel();
			contentPane.setLayout(new FlowLayout());
			Label title = new Label("*************************************** PhokU Media Library Lister ***************************************",Label.CENTER);
			contentPane.add(title);
			dir = new TextField(150);
			dir.setText("Browse Directory to list");
			contentPane.add(dir);
			scan = new Button("Scan");
			contentPane.add(scan);
			artistModel = new DefaultListModel();
			albumModel = new DefaultListModel();
			trackModel = new DefaultListModel();
			artists = new JList(artistModel);
			albums = new JList(albumModel);
			tracks = new JList(trackModel);

			/* add items dynamically */
		
			artistPanel = new JScrollPane(artists);
			albumPanel = new JScrollPane(albums);
			trackPanel = new JScrollPane(tracks);
			artists.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			albums.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			tracks.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			window = new JFrame("PhokU Media Library Manager");
			artistPanel.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
			artistPanel.setPreferredSize(new Dimension(250, 250));
			albumPanel.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
			albumPanel.setPreferredSize(new Dimension(250, 250));
			trackPanel.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
			trackPanel.setPreferredSize(new Dimension(250, 250));
			contentPane.add(artistPanel);
			contentPane.add(albumPanel);
			contentPane.add(trackPanel);
			status = new JLabel("Idle");
			contentPane.add(status);
			window.getContentPane().add(contentPane);
			Class.forName(driver).newInstance();
			conn = DriverManager.getConnection(url+db, user, pass);
			System.out.println("Connection formed");
			populate = conn.createStatement();
			popAlbum = conn.createStatement();
			popTrack = conn.createStatement();
			scan.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent ae) {
					System.out.println("Scanning directory...");
					status.setText("Scanning directory....");
					try {
					FileOps oFileOps = new FileOps(dir.getText());
					rs = populate.executeQuery("select distinct(artist) from main");
					while (rs.next()) {
						artistModel.addElement(rs.getString("artist"));
					}
					status.setText("Scan complete.");
					} catch (SQLException e) {System.out.println("SQLException occured in PhokUi");}
				}
			});
			artists.addListSelectionListener(new ListSelectionListener() {
				public void valueChanged(ListSelectionEvent lse) {
					try {
					rs = popAlbum.executeQuery("select distinct(album) from main where artist = '" + artistModel.getElementAt(artists.getSelectedIndex()).toString() + "'");
					trackModel.clear();
					albumModel.clear();
					while (rs.next()) {
						albumModel.addElement(rs.getString("album"));
					}
					} catch (SQLException e) { }
				}
			});
			albums.addListSelectionListener(new ListSelectionListener() {
				public void valueChanged(ListSelectionEvent lse) {
					try {
					rs = popTrack.executeQuery("select track from main where album = '" + albumModel.getElementAt(albums.getSelectedIndex()).toString() + "'");
					trackModel.clear();
					while (rs.next()) {
						trackModel.addElement(rs.getString("track"));
					}
					} catch (SQLException e) { }
				}
			});
		}
		catch (SQLException e) {System.out.println("SQLException caught in PhokUi"); }
		catch (ClassNotFoundException e) {System.out.println("Class not found"); }
		catch (Exception e) {System.out.println("Exception Occured in PhokUi"); }
		window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		window.pack();
		window.show();
	}
}
</phokUi.java>

File 2:
<FileOps.java>
import java.io.*;
import org.blinkenlights.jid3.*;
import org.blinkenlights.jid3.v1.*;
import org.blinkenlights.jid3.v2.*;
import java.sql.*;

/*************************************************************************************************************************
 * The file operations class. Scans the user selected directory recursively for media of MP3 type, retrieves the ID3 Tags
 * and enters the values into the database. 
 * @author: Saahil
 * *************************************************************************************************************************/

class FileOps {
	static Connection conn = null;

	//The constructor. Clears the database, everytime a new parent directory is selected. 
	FileOps(String path) throws SQLException {
		String driver = "com.mysql.jdbc.Driver";
		String url = "jdbc:mysql://localhost/";
		String db = "music";
		String user = "phoku";
		String pass = "phoku";

		try {
			Class.forName(driver).newInstance();
			conn = DriverManager.getConnection(url+db, user, pass);
			Statement stmt = conn.createStatement();
			stmt.executeUpdate("delete from main");
			conn.close();
			getTrackList(path);
		}
		catch (Exception e) {}
	}


	// Scans the directory for MP3 files
	static void getTrackList(String dirPath) throws ID3Exception, IOException, SQLException{
		MediaFile iMediaFile;
		String track = new String();
		String album = new String();
		String artist = new String();
		try {
			File dir = new File(dirPath);
			if (dir.isDirectory()) {
				String[] flList = dir.list();
				int len = flList.length;

				for (int i = 0; i < len; i++) {
					File f = new File(dirPath + "/" + flList[i]);
					String fileName = dirPath + "/" + flList[i];
					if (!f.isDirectory()) {
						if (fileName.endsWith("mp3")){
							iMediaFile = new MP3File(f);
							ID3Tag[] oTags = iMediaFile.getTags();
							if (oTags[0] instanceof ID3V1_0Tag) {
								ID3V1_0Tag oActTag = (ID3V1_0Tag)oTags[0];
								track = oActTag.getTitle();
								album = oActTag.getAlbum();
								artist = oActTag.getArtist();
								insertIntoDb(fileName, track, album, artist);
							}
							else if (oTags[0] instanceof ID3V1_1Tag) {
								ID3V1_1Tag oActTag = (ID3V1_1Tag)oTags[0];
								track = oActTag.getTitle();
								album = oActTag.getAlbum();
								artist = oActTag.getArtist();
								insertIntoDb(fileName, track, album, artist);
							}
						}
					}
					// Recursive call if current File object points to a directory
					else
						getTrackList(fileName);
				}
			}
			else 
				throw new FileNotFoundException();
			
			}
		catch (IOException e) {
			System.out.println("Path doesn't exist or is not a directory");
		}
		catch(ID3Exception e) {System.out.println("Other");}
	}
	
	//Populates the database 
	static void insertIntoDb(String fileName, String track, String album, String artist) throws SQLException  {
		String url = "jdbc:mysql://localhost/";
		String dbName = "music";
		String user = "phoku";
		String pass = "phoku";
		String driver = "com.mysql.jdbc.Driver";
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url+dbName, user, pass);
			Statement stmt = conn.createStatement();
			stmt.executeUpdate("Insert into main values ('" + fileName + "', '" + track + "', '" + album + "', '" + artist + "')");
			conn.close();
		}
		catch(ClassNotFoundException e) {}
		catch(SQLException e) {}
		catch(Exception e) {}
	}
	
}

</FileOps.java>
Okay, I need to modernize this Java code to version 17. Let me start by looking at both files and see what can be updated.

First, looking at PhokUi.java. The code uses AWT and Swing components, which are still okay in Java 17, but some practices might be outdated. For example, they're using raw types for JList and DefaultListModel. I should parameterize them with generics, like JList<String> and DefaultListModel<String>. That will help with type safety.

Also, initializing strings with 'new String()' is unnecessary. Like driver = new String(); driver = "com.mysql.jdbc.Driver"; can be simplified to driver = "com.mysql.jdbc.Driver";. So I'll remove those redundant initializations.

The main method throws SQLException, but in the catch blocks, they're catching exceptions. Maybe better to handle exceptions properly, but the original code catches them. However, using multi-catch in Java 7+ could clean that up if needed, but maybe that's beyond just modernizing syntax.

The code uses anonymous inner classes for ActionListener and ListSelectionListener. Since Java 8, we can use lambda expressions for single-method interfaces. For example, scan.addActionListener(e -> {...}); That would make the code cleaner.

In the PhokUi class, variables like JList artists, albums, tracks are declared as static. But using static for UI components isn't great practice. However, since this is a simple main class, maybe it's acceptable. But perhaps refactoring to an instance-based approach would be better, but the user might just want minimal changes to update to Java 17 features.

Also, the window.show() method is deprecated; should use window.setVisible(true) instead.

Looking at the JDBC driver: the original uses "com.mysql.jdbc.Driver", but in newer MySQL versions, the driver is "com.mysql.cj.jdbc.Driver". The URL might need to include timezone settings, like adding ?useSSL=false&serverTimezone=UTC. But the user's code might expect the old driver. Need to check if that's part of the modernization. Maybe the user is using an older MySQL connector, but for Java 17, they might need the newer driver. So updating the driver string and URL might be necessary.

In FileOps.java, similar issues with string initialization. Also, the use of Class.forName(driver).newInstance() is deprecated. The preferred way is to use Class.forName(driver).getDeclaredConstructor().newInstance(). But actually, since JDBC 4.0, drivers are auto-loaded, so maybe just removing the Class.forName part is possible. But the original code uses it, so perhaps updating to the new driver class and using getDeclaredConstructor().newInstance().

Another point is using try-with-resources for database connections, statements, and result sets to prevent resource leaks. The original code doesn't close resources properly. For example, in the FileOps constructor, after getting the connection, they create a statement and execute an update, then close the connection. But if an exception occurs, the close might not be called. Using try-with-resources would be better.

Also, in PhokUi, the ResultSet rs is static and used in multiple places. ResultSets should be closed after use. But the original code doesn't do that. However, modifying that might require more structural changes. Since the user wants modernization to Java 17, maybe focusing on syntax and language features rather than architectural changes unless necessary.

String concatenation in SQL queries is a big no-no due to SQL injection. But since this is a local application, maybe it's acceptable. However, using PreparedStatement would be better. But that's more of a security improvement than a modernization. The user might not want that unless specified.

In the insertIntoDb method in FileOps.java, they're catching exceptions and doing nothing. That's bad practice. At least logging the exceptions. But the original code does that, so maybe leave as-is unless instructed otherwise.

Now, considering Java 17 features:

- Switch expressions? Not sure if applicable here.

- Records: Maybe not necessary unless restructuring data.

- Text blocks: For SQL strings, could make them more readable.

- Pattern matching for instanceof: In FileOps.java, they check if oTags[0] is an instance of ID3V1_0Tag or ID3V1_1Tag. Using pattern matching could simplify that.

For example:

Original code:

if (oTags[0] instanceof ID3V1_0Tag) {

ID3V1_0Tag oActTag = (ID3V1_0Tag)oTags[0];

...

}

Can be written with pattern matching:

if (oTags[0] instanceof ID3V1_0Tag oActTag) {

// use oActTag directly

}

Same for ID3V1_1Tag. That's a Java 16+ feature.

Another thing: The use of raw types in the ListModels. Changing DefaultListModel to DefaultListModel<String> and JList to JList<String>.

In PhokUi.java, the JList variables are declared as static. Should change their declarations to:

static JList<String> artists, albums, tracks;

And the models:

static DefaultListModel<String> artistModel, albumModel, trackModel;

Then initializing them with:

artistModel = new DefaultListModel<>();

// same for others

Also, when getting elements from the model, using artistModel.getElementAt(...) would return a String, so no need for toString().

In the listeners, when they do artistModel.getElementAt(artists.getSelectedIndex()).toString(), with generics, this can be simplified to artistModel.getElementAt(...), since it's a String.

Regarding the JDBC URL: For MySQL Connector/J 8.x, the URL should be "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC" to avoid warnings and timezone issues. So updating the url variable in both files.

Also, the MySQL driver class is now "com.mysql.cj.jdbc.Driver", so changing driver variables to that.

In the PhokUi main method, the line Class.forName(driver).newInstance(); is deprecated. Should use getDeclaredConstructor().newInstance(), but actually, since JDBC 4.0, the driver is automatically loaded when the DriverManager gets a connection. So perhaps removing the Class.forName line. Let me check: The original code does Class.forName(driver).newInstance(); which was necessary for older JDBC drivers. But with MySQL Connector/J 8.0+, the driver is automatically registered. So maybe that line can be removed. However, the original code might have needed it. So perhaps replacing it with just Class.forName(driver) (without instantiating) or removing it altogether.

But the code in PhokUi has:

Class.forName(driver).newInstance();

Which is incorrect because Class.forName() returns the Class object, and newInstance() is called on that, which would create an instance of the driver, but actually, the DriverManager should handle it. So perhaps that line is unnecessary and can be removed. Because DriverManager.getConnection() will load the driver automatically if it's on the classpath.

So removing that line might be possible, but since the original code uses it, maybe just updating the driver string.

In FileOps.java's constructor, they have:

Class.forName(driver).newInstance();

Same issue here. Should update to the new driver class and possibly remove that line if possible.

Another thing: In PhokUi.java, when adding elements to the JList models, they should be done on the Event Dispatch Thread (EDT). The actionPerformed in the scan button's listener does database operations and updates the UI. Those UI updates should be wrapped in SwingUtilities.invokeLater() to ensure they're on the EDT.

But the original code might not be doing that. However, since the actionPerformed is called from the EDT (as it's a Swing event), maybe it's okay. But database operations in the EDT can freeze the UI. So perhaps moving the scanning to a background thread. But that's a larger change. Since the user asked for modernization to Java 17, maybe not required unless part of concurrency improvements.

But the original code might have the issue of blocking the UI when scanning. However, that's beyond just modernizing syntax.

So steps to modernize:

1. Update JDBC driver and URL.

2. Use generics for JList and DefaultListModel.

3. Replace anonymous inner classes with lambdas where possible.

4. Replace deprecated method calls (window.show() -> setVisible(true)).

5. Use try-with-resources for database resources.

6. Apply pattern matching for instanceof where applicable.

7. Remove redundant String initializations.

8. Fix any resource leaks by closing ResultSet, Statements, Connections properly.

9. Use multi-catch in exceptions if applicable.

10. Replace Class.forName().newInstance() with appropriate code if needed.

Starting with PhokUi.java:

- Change driver to "com.mysql.cj.jdbc.Driver".

- URL includes serverTimezone and useSSL parameters.

- Generics for JList and models.

- Lambda expressions for listeners.

- window.setVisible(true) instead of show().

- Remove redundant new String() initializations.

- Check exception handling, perhaps using multi-catch.

- Replace Class.forName().newInstance() with Class.forName(), since DriverManager auto-registers.

Similarly in FileOps.java:

- Update driver and URL.

- Use try-with-resources for connections, statements.

- Pattern matching for instanceof in ID3 tags.

- Use generics if any collections are involved.

- Close resources properly.

Let me start modifying PhokUi.java:

Original lines:

driver = "com.mysql.jdbc.Driver";

url = "jdbc:mysql://localhost/";

db = "music";

Change driver to "com.mysql.cj.jdbc.Driver".

URL should be "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC".

Wait, original code uses url+db. So url is "jdbc:mysql://localhost/", db is "music". So the connection URL would be "jdbc:mysql://localhost/music". But with parameters, it should be "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC".

So perhaps in PhokUi, set url to "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC" and remove the db variable. Or adjust the code accordingly. Let me check:

Original code:

conn = DriverManager.getConnection(url+db, user, pass);

If url is "jdbc:mysql://localhost/", then url+db is "jdbc:mysql://localhost/music".

But with parameters, the URL should be "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC". So in the code, setting url to that value directly and removing the db variable.

So in PhokUi:

Change:

url = "jdbc:mysql://localhost/";

db = "music";

To:

url = "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC";

Then, when creating the connection:

conn = DriverManager.getConnection(url, user, pass);

Similarly in FileOps.java:

Original code:

url = "jdbc:mysql://localhost/";

dbName = "music";

Change to:

url = "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC";

Then connect using url.

Next, in PhokUi's main method:

Original lines:

Class.forName(driver).newInstance();

conn = DriverManager.getConnection(url+db, user, pass);

Replace with:

conn = DriverManager.getConnection(url, user, pass);

Because the driver is auto-loaded, so the Class.forName line can be removed. However, some older versions might require it, but with MySQL Connector/J 8.0+, it's not needed. So removing that line.

But in the original code, it's in a try block. Let me check:

Original code:

Class.forName(driver).newInstance();

conn = DriverManager.getConnection(url+db, user, pass);

But if we remove the Class.forName line, the code would still work. So removing that line.

In the catch block for ClassNotFoundException, that can be removed as well, since we're not calling Class.forName anymore.

Wait, the original code has:

catch (ClassNotFoundException e) {System.out.println("Class not found"); }

But if we remove the Class.forName line, this catch is unnecessary. So modifying the try block to not include that.

So in PhokUi's main method, the code inside the try block:

Original:

Class.forName(driver).newInstance();

conn = DriverManager.getConnection(url+db, user, pass);

Modified:

conn = DriverManager.getConnection(url, user, pass);

So the ClassNotFoundException catch can be removed. Let me adjust the catch blocks.

Original catch blocks:

catch (SQLException e) { ... }

catch (ClassNotFoundException e) { ... }

catch (Exception e) { ... }

After removing Class.forName, the ClassNotFoundException catch is no longer needed, so removing that.

So the catch blocks become:

catch (SQLException e) { ... }

catch (Exception e) { ... }

But in the original code, they had Class.forName(driver).newInstance(), which could throw InstantiationException or IllegalAccessException. Since we're removing that line, those exceptions are no longer possible.

Wait, the original code's try block includes:

Class.forName(driver).newInstance();

Which can throw ClassNotFoundException, InstantiationException, IllegalAccessException. But once we remove that line, those exceptions are not thrown here. The remaining code that could throw SQLException is DriverManager.getConnection(...), which is already in a try block.

Wait, the original code had:

try {

... code including Class.forName and DriverManager.getConnection...

}

catch (SQLException e) { ... }

catch (ClassNotFoundException e) { ... }

catch (Exception e) { ... }

If we remove the Class.forName line, then the ClassNotFoundException catch is no longer needed. But DriverManager.getConnection can throw SQLException, which is caught.

So the modified catch blocks would be:

catch (SQLException e) { ... }

catch (Exception e) { ... }

But the original code had a ClassNotFoundException catch, which is now obsolete.

So adjusting the code.

Now, the generics for JList and DefaultListModel.

Original declarations:

static DefaultListModel artistModel, albumModel, trackModel;

static JList artists, albums, tracks;

Change to:

static DefaultListModel<String> artistModel, albumModel, trackModel;

static JList<String> artists, albums, tracks;

Then, when initializing:

artistModel = new DefaultListModel<>();

albums = new JList<>(albumModel);

// etc.

In the code where elements are added:

artistModel.addElement(rs.getString("artist")); // This is fine.

In the ListSelectionListeners:

Original:

rs = popAlbum.executeQuery("select distinct(album) from main where artist = '" + artistModel.getElementAt(artists.getSelectedIndex()).toString() + "'");

But with generics, artists.getSelectedIndex() returns a String, so no need for toString().

Change to:

artistModel.getElementAt(artists.getSelectedIndex())

Similarly for albumModel.

In the actionPerformed for scan button:

Inside, the code calls artistModel.addElement(rs.getString("artist")).

That's okay.

Now, for lambda expressions:

Original scan.addActionListener(new ActionListener() { ... });

Replace with:

scan.addActionListener(e -> {

// code here

});

Same for the list selection listeners.

Original:

artists.addListSelectionListener(new ListSelectionListener() {

public void valueChanged(ListSelectionEvent lse) {

// code

}

});

Replace with:

artists.addListSelectionListener(e -> {

if (!e.getValueIsAdjusting()) {

// code

}

});

Wait, in the original code, the valueChanged method may trigger multiple times while the selection is changing. It's common to check if e.getValueIsAdjusting() is false to process only once. The original code didn't do this, but maybe it's an improvement. However, since the user wants to modernize, perhaps leave the logic as is but convert to lambda.

So:

artists.addListSelectionListener(e -> {

if (!e.getValueIsAdjusting()) {

try {

// existing code

} catch (SQLException ex) { }

}

});

But the original code didn't check for valueIsAdjusting, so maybe the lambda should mirror that. So the code becomes:

artists.addListSelectionListener(e -> {

try {

// code

} catch (SQLException ex) { }

});

But in the original code, the ListSelectionListener's valueChanged method may fire multiple times. However, the original code didn't handle that. So maybe the lambda is sufficient as a direct replacement.

Now, window.show() is deprecated; replace with window.setVisible(true).

In the main method:

Original:

window.show();

Change to:

window.setVisible(true);

Now, redundant String initializations:

Original:

driver = new String();

driver = "com.mysql.jdbc.Driver";

This is redundant. Just assign the string directly:

driver = "com.mysql.cj.jdbc.Driver";

Same for other variables like url, db, user, pass. Remove the new String() lines.

So in PhokUi's main method:

Original:

driver = new String();

driver = "com.mysql.jdbc.Driver";

url = new String();

url = "jdbc:mysql://localhost/";

db = new String();

db = "music";

user = new String();

user = "phoku";

pass = new String();

pass = "phoku";

Change to:

driver = "com.mysql.cj.jdbc.Driver";

url = "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC";

user = "phoku";

pass = "phoku";

And remove the db variable, as it's now part of the URL.

Now, in the SQL queries, string concatenation is used, which is a SQL injection risk. But since this is a local app and the data comes from ID3 tags, maybe it's acceptable. However, using PreparedStatement would be better. But the user asked for modernization, not security fixes. So perhaps leave as is for now.

In FileOps.java's insertIntoDb method, they create a new connection each time. That's inefficient. Should reuse connections, but the original code may not. However, using try-with-resources would help in closing resources.

In the FileOps constructor, they delete existing records, then scan. The original code uses a Statement to delete.

In the constructor:

stmt.executeUpdate("delete from main");

But using try-with-resources:

try (Statement stmt = conn.createStatement()) {

stmt.executeUpdate("delete from main");

}

But the original code has conn.close() after that. But with try-with-resources, the Statement is auto-closed, but the connection should be closed after use.

But in the original code, after deleting, they call conn.close(), then call getTrackList(path). But getTrackList opens a new connection each time. That's not efficient. However, perhaps the user wants to focus on modernization, not optimization.

In FileOps.java's getTrackList method:

They process each file, and for MP3s, read ID3 tags. Then call insertIntoDb.

In insertIntoDb, each insertion opens a new connection. This is very inefficient. Should pass a connection or use a connection pool. But again, beyond modernization.

For modernization, in insertIntoDb, use try-with-resources for the connection and statement.

Original:

Class.forName(driver);

conn = DriverManager.getConnection(url+dbName, user, pass);

Statement stmt = conn.createStatement();

stmt.executeUpdate(...);

conn.close();

Change to:

try (Connection conn = DriverManager.getConnection(url, user, pass);

Statement stmt = conn.createStatement()) {

stmt.executeUpdate(...);

} catch (SQLException e) { ... }

But need to adjust the url variable in FileOps to the new one with parameters.

Also, in FileOps's constructor:

Original:

conn = DriverManager.getConnection(url+db, user, pass);

stmt.executeUpdate("delete from main");

conn.close();

Change to using try-with-resources:

try (Connection conn = DriverManager.getConnection(url, user, pass);

Statement stmt = conn.createStatement()) {

stmt.executeUpdate("delete from main");

} // connection is auto-closed

Then call getTrackList(path).

But in the original code, after deleting, the connection is closed, then getTrackList is called, which opens new connections for each insert. Which is not efficient but perhaps unavoidable in the current structure.

Now, applying pattern matching for instanceof in FileOps.java:

Original:

if (oTags[0] instanceof ID3V1_0Tag) {

ID3V1_0Tag oActTag = (ID3V1_0Tag)oTags[0];

...

} else if (oTags[0] instanceof ID3V1_1Tag) {

ID3V1_1Tag oActTag = (ID3V1_1Tag)oTags[0];

...

}

Change to:

if (oTags[0] instanceof ID3V1_0Tag oActTag) {

track = oActTag.getTitle();

...

} else if (oTags[0] instanceof ID3V1_1Tag oActTag) {

track = oActTag.getTitle();

...

}

This uses pattern matching, available since Java 16.

Now, in FileOps.java's getTrackList method, the variables track, album, artist are initialized as new String(), which is unnecessary. Just declare them as String and assign values.

Original:

String track = new String();

String album = new String();

String artist = new String();

Change to:

String track = "";

String album = "";

String artist = "";

Or:

String track, album, artist;

But need to ensure they are initialized. Since in the if/else blocks they get assigned, maybe initialize to empty strings.

Now, checking for exceptions in FileOps.java:

In the constructor, after deleting from main, getTrackList is called. getTrackList can throw ID3Exception, IOException, SQLException. But the constructor's try block catches all exceptions with catch (Exception e) {}. So any exceptions in getTrackList would be caught there. But the original code does nothing with them. That's probably not ideal, but the user may want to keep that behavior.

Now, updating the JDBC code to use try-with-resources where possible.

In PhokUi's actionPerformed for the scan button:

Original:

rs = populate.executeQuery("select distinct(artist) from main");

while (rs.next()) {

artistModel.addElement(rs.getString("artist"));

}

But rs is not closed. Should use try-with-resources.

But rs is declared as static, which is a bad practice. But changing that would require structural changes. Instead, perhaps inside the actionPerformed, use a try-with-resources when executing the query.

Modified code:

try (ResultSet rs = populate.executeQuery("select distinct(artist) from main")) {

while (rs.next()) {

artistModel.addElement(rs.getString("artist"));

}

} catch (SQLException e) { ... }

But since populate is a Statement, which is created once, we can't use try-with-resources on it. However, each executeQuery should have its own ResultSet properly closed.

So changing the code to use try-with-resources for the ResultSet.

Similarly in the list selection listeners, the rs is a static variable. That's problematic because multiple listeners could overwrite it, leading to resource leaks. Instead, each query should have its own ResultSet in a try-with-resources block.

For example, in the artists' list selection listener:

Original:

rs = popAlbum.executeQuery(...);

...

while (rs.next()) { ... }

Change to:

try (ResultSet rs = popAlbum.executeQuery(...)) {

albumModel.clear();

trackModel.clear();

while (rs.next()) {

albumModel.addElement(rs.getString("album"));

}

} catch (SQLException e) { ... }

But popAlbum is a Statement created once. Using the same Statement for multiple queries is acceptable, but each ResultSet should be closed. By using try-with-resources on the ResultSet, they are properly closed after use.

But in Java, a ResultSet is closed when the Statement is closed or reused. However, using try-with-resources for each ResultSet is better practice.

This requires modifying the code in the listeners to declare the ResultSet inside the try block.

So, in PhokUi's list selection listeners:

Original artists listener:

rs = popAlbum.executeQuery("select distinct(album) from main where artist = '" + artistModel.getElementAt(...) + "'");

albumModel.clear();

trackModel.clear();

while (rs.next()) { ... }

Change to:

try {

String artist = artistModel.getElementAt(artists.getSelectedIndex());

try (ResultSet rs = popAlbum.executeQuery("select distinct(album) from main where artist = '" + artist + "'")) {

albumModel.clear();

trackModel.clear();

while (rs.next()) {

albumModel.addElement(rs.getString("album"));

}

}

} catch (SQLException ex) { ... }

Same for albums listener.

This ensures that each ResultSet is closed after use.

But this requires modifying how the queries are executed. However, since the original code uses static Statements (populate, popAlbum, popTrack), which are created once, reusing them is okay. But using the same Statement for multiple queries while processing the previous ResultSet could cause issues. However, by using try-with-resources on the ResultSet, we close each ResultSet properly.

Now, these changes would modernize the code by using try-with-resources, lambdas, generics, updated JDBC driver, and pattern matching.

Another thing: In PhokUi, the status.setText("Scanning directory...."); is called on the EDT, but the scanning process (FileOps) is done on the EDT, which would block the UI. To prevent freezing, the scanning should be done in a background thread. However, since the user asked for modernization to Java 17, perhaps using a SwingWorker or CompletableFuture. But this is an enhancement. Since the original code didn't handle this, maybe it's beyond the scope of just modernizing syntax. But for responsiveness, it's worth considering.

But the user might not want structural changes, so perhaps leave as-is for now.

Putting all these changes together:

PhokUi.java modifications:

- Update driver and URL.

- Use generics for JList and models.

- Use lambdas for listeners.

- Replace window.show() with setVisible(true).

- Remove redundant String initializations.

- Use try-with-resources for ResultSet in listeners and actionPerformed.

- Remove Class.forName lines.

- Adjust exception handling.

FileOps.java modifications:

- Update driver and URL.

- Use try-with-resources for connections and statements.

- Use pattern matching for instanceof.

- Remove redundant String initializations.

- Use try-with-resources in insertIntoDb.

To modernize the code to Java 17, several updates and best practices have been applied, including using newer JDBC drivers, generics, lambdas, try-with-resources, and pattern matching. Here are the revised files:

phokUi.java

java
Copy
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import javax.swing.event.*;
import java.sql.*;
import java.io.*;

public class PhokUi {
    static JList<String> artists, albums, tracks;
    static TextField dir;
    static Button scan;
    static Connection conn;
    static String driver = "com.mysql.cj.jdbc.Driver";
    static String url = "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC";
    static String user = "phoku";
    static String pass = "phoku";
    static JScrollPane artistPanel, albumPanel, trackPanel;
    static DefaultListModel<String> artistModel, albumModel, trackModel;
    static JFrame window;
    static JLabel status;
    static Statement populate, popAlbum, popTrack;

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            try {
                JPanel contentPane = new JPanel(new FlowLayout());
                Label title = new Label("*************************************** PhokU Media Library Lister ***************************************", Label.CENTER);
                contentPane.add(title);
                dir = new TextField(150);
                dir.setText("Browse Directory to list");
                contentPane.add(dir);
                scan = new Button("Scan");
                contentPane.add(scan);

                artistModel = new DefaultListModel<>();
                albumModel = new DefaultListModel<>();
                trackModel = new DefaultListModel<>();
                artists = new JList<>(artistModel);
                albums = new JList<>(albumModel);
                tracks = new JList<>(trackModel);

                artistPanel = new JScrollPane(artists);
                albumPanel = new JScrollPane(albums);
                trackPanel = new JScrollPane(tracks);
                artists.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                albums.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                tracks.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

                window = new JFrame("PhokU Media Library Manager");
                artistPanel.setPreferredSize(new Dimension(250, 250));
                albumPanel.setPreferredSize(new Dimension(250, 250));
                trackPanel.setPreferredSize(new Dimension(250, 250));
                contentPane.add(artistPanel);
                contentPane.add(albumPanel);
                contentPane.add(trackPanel);

                status = new JLabel("Idle");
                contentPane.add(status);
                window.getContentPane().add(contentPane);

                conn = DriverManager.getConnection(url, user, pass);
                populate = conn.createStatement();
                popAlbum = conn.createStatement();
                popTrack = conn.createStatement();

                scan.addActionListener(e -> {
                    status.setText("Scanning directory....");
                    new SwingWorker<Void, Void>() {
                        @Override
                        protected Void doInBackground() throws Exception {
                            new FileOps(dir.getText());
                            try (ResultSet rs = populate.executeQuery("SELECT DISTINCT artist FROM main")) {
                                artistModel.clear();
                                while (rs.next()) {
                                    artistModel.addElement(rs.getString("artist"));
                                }
                            }
                            return null;
                        }

                        @Override
                        protected void done() {
                            status.setText("Scan complete.");
                        }
                    }.execute();
                });

                artists.addListSelectionListener(e -> {
                    if (!e.getValueIsAdjusting()) {
                        try {
                            String artist = artists.getSelectedValue();
                            try (ResultSet rs = popAlbum.executeQuery("SELECT DISTINCT album FROM main WHERE artist = '" + artist + "'")) {
                                albumModel.clear();
                                trackModel.clear();
                                while (rs.next()) {
                                    albumModel.addElement(rs.getString("album"));
                                }
                            }
                        } catch (SQLException ex) {
                            ex.printStackTrace();
                        }
                    }
                });

                albums.addListSelectionListener(e -> {
                    if (!e.getValueIsAdjusting()) {
                        try {
                            String album = albums.getSelectedValue();
                            try (ResultSet rs = popTrack.executeQuery("SELECT track FROM main WHERE album = '" + album + "'")) {
                                trackModel.clear();
                                while (rs.next()) {
                                    trackModel.addElement(rs.getString("track"));
                                }
                            }
                        } catch (SQLException ex) {
                            ex.printStackTrace();
                        }
                    }
                });

                window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                window.pack();
                window.setVisible(true);
            } catch (SQLException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(window, "Database connection failed.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        });
    }
}
FileOps.java

java
Copy
import java.io.*;
import org.blinkenlights.jid3.*;
import org.blinkenlights.jid3.v1.*;
import org.blinkenlights.jid3.v2.*;
import java.sql.*;

class FileOps {
    static final String URL = "jdbc:mysql://localhost/music?useSSL=false&serverTimezone=UTC";
    static final String USER = "phoku";
    static final String PASS = "phoku";

    FileOps(String path) throws SQLException {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASS);
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DELETE FROM main");
            getTrackList(path);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static void getTrackList(String dirPath) throws ID3Exception, IOException, SQLException {
        File dir = new File(dirPath);
        if (dir.isDirectory()) {
            String[] flList = dir.list();
            if (flList != null) {
                for (String file : flList) {
                    File f = new File(dir, file);
                    if (f.isDirectory()) {
                        getTrackList(f.getAbsolutePath());
                    } else if (f.getName().endsWith(".mp3")) {
                        processMP3File(f);
                    }
                }
            }
        } else {
            throw new FileNotFoundException("Path does not exist or is not a directory: " + dirPath);
        }
    }

    private static void processMP3File(File f) throws ID3Exception, IOException, SQLException {
        try (MP3File iMediaFile = new MP3File(f)) {
            ID3Tag[] oTags = iMediaFile.getTags();
            if (oTags.length > 0) {
                String track = "", album = "", artist = "";
                if (oTags[0] instanceof ID3V1_0Tag oActTag) {
                    track = oActTag.getTitle();
                    album = oActTag.getAlbum();
                    artist = oActTag.getArtist();
                } else if (oTags[0] instanceof ID3V1_1Tag oActTag) {
                    track = oActTag.getTitle();
                    album = oActTag.getAlbum();
                    artist = oActTag.getArtist();
                }
                insertIntoDb(f.getAbsolutePath(), track, album, artist);
            }
        }
    }

    static void insertIntoDb(String fileName, String track, String album, String artist) {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASS);
             PreparedStatement pstmt = conn.prepareStatement("INSERT INTO main VALUES (?, ?, ?, ?)")) {
            pstmt.setString(1, fileName);
            pstmt.setString(2, track);
            pstmt.setString(3, album);
            pstmt.setString(4, artist);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
Key Changes:

JDBC Driver Update: Uses MySQL Connector/J 8.x driver and updated URL with timezone settings.

Generics: Added type parameters for JList and DefaultListModel.

Lambdas and SwingWorker: Replaced anonymous inner classes with lambdas and used SwingWorker for background tasks to keep the UI responsive.

Try-with-Resources: Ensured proper resource management for database connections and result sets.

Pattern Matching: Simplified instanceof checks with Java 16+ pattern matching.

Code Cleanup: Removed redundant initializations, improved exception handling, and used prepared statements to prevent SQL injection.

UI Enhancements: Replaced deprecated show() with setVisible(true) and improved error dialogs.

